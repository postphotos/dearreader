#!/usr/bin/env bash

# DearReader - Unified Project Manager
# A delightful CLI for managing the DearReader web crawler

# Exit immediately if a command exits with a non-zero status.
set -e

# --- Portability Fix ---
# Get the directory where this script is located and navigate to project root.
# This approach is more portable than `readlink -f` which is not available on macOS by default.
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
PROJECT_ROOT="$SCRIPT_DIR"
cd "$PROJECT_ROOT"

# Global variable for uv usage
USE_UV=false

# Color and formatting constants
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Emoji constants
ROCKET="🚀"
GEAR="⚙️"
CHECK="✅"
CROSS="❌"
WARNING="⚠️"
INFO="ℹ️"
BOOK="📚"
DOCKER="🐳"
PYTHON="🐍"
NODE="🟢"
TEST="🧪"
STOP="🛑"
SPARKLES="✨"
HEART="❤️"

# Logging functions with colors and emojis
log_info() {
    echo -e "${BLUE}${INFO}${NC} $1"
}

log_success() {
    echo -e "${GREEN}${CHECK}${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}${WARNING}${NC} $1"
}

log_error() {
    echo -e "${RED}${CROSS}${NC} $1"
}

log_header() {
    echo -e "\n${MAGENTA}${BOLD}$1${NC}"
    echo -e "${MAGENTA}$(printf '%.0s=' {1..50})${NC}"
}

log_subheader() {
    echo -e "${CYAN}${BOLD}$1${NC}"
}

# Show beautiful help
show_help() {
    cat <<'EOF'

╔══════════════════════════════════════════════════════════════╗
║                     📚 DearReader CLI                       ║
║              Web Content Extraction Made Simple             ║
╚══════════════════════════════════════════════════════════════╝

USAGE:
    ./dearreader <command> [subcommand] [options]

COMMANDS:
    setup           🏗️  Set up development environment
    dev             🚀  Start development environment
    test            🧪  Run tests (js, python, e2e, pipeline, or all) - defaults to all
    run             ▶️   Start services (dev/prod)
    stop            🛑  Stop all services
    status          📊  Show system status
    logs            📝  Show service logs
    clean           🧹  Clean up containers and volumes
    migration       📋  Show migration status and tips
    task            📋  Manage pipeline tasks (list, status, enable, disable)

OPTIONS:
    --verbose|-v    Show detailed output
    --force|-f      Continue despite errors
    --follow|-F     Follow logs in real-time

EXAMPLES:
    ./dearreader setup              # First-time setup
    ./dearreader dev                # Start development
    ./dearreader test               # Run all tests (default)
    ./dearreader test e2e           # Run end-to-end tests only
    ./dearreader test js            # Run JavaScript tests only
    ./dearreader test python        # Run Python tests only
    ./dearreader test pipeline      # Run pipeline tests only
    ./dearreader run prod           # Start production
    ./dearreader status             # Check system status
    ./dearreader api test           # Test API endpoints
    ./dearreader task list          # List all available pipeline tasks
    ./dearreader task status        # Show task status (enabled/disabled)
    ./dearreader task enable <task> # Enable a specific task
    ./dearreader task disable <task># Disable a specific task

QUICK START:
    1. ./scripts/quickstart.sh    # 1-click setup (fastest!)
    2. ./dearreader setup         # Manual setup
    3. ./dearreader dev           # Start development
    4. Open http://localhost:3001

EOF
}

# Check if Docker is available
check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        log_error "Docker is not installed or not in PATH"
        echo "Please install Docker: https://www.docker.com/get-started"
        exit 1
    fi

    if ! docker version >/dev/null 2>&1; then
        log_error "Docker daemon is not running"
        echo "Please start Docker and try again"
        exit 1
    fi

    if ! command -v docker-compose >/dev/null 2>&1; then
        log_error "Docker Compose is not installed"
        echo "Please install Docker Compose"
        exit 1
    fi
}

# Cross-platform command execution with better feedback and security.
run_cmd() {
    local description="$1"
    shift
    local cmd_str="$*"

    log_info "$description..."

    if [ "$VERBOSE" = true ]; then
        echo -e "${CYAN}  └─ ${cmd_str}${NC}"
        # Execute with output visible
        "$@"
        return $?
    else
        # Execute and capture stderr on failure
        local stderr
        stderr=$("$@" 2>&1 >/dev/null)
        local exit_code=$?
        if [ $exit_code -ne 0 ]; then
            log_error "Failed: $description"
            echo -e "${RED}Error details:${NC}\n$stderr" >&2
            return $exit_code
        fi
    fi
}

# Checks for a command and provides installation instructions if missing.
check_dependency() {
    local cmd="$1"
    local package="$2"
    local instructions="$3"

    if ! command -v "$cmd" >/dev/null 2>&1; then
        log_warn "$package not found. This is required for some features."
        echo -e "${YELLOW}To install it, please run:${NC}"
        echo -e "  $instructions"
        return 1
    else
        log_success "$package is installed"
        return 0
    fi
}

# Setup command - comprehensive environment setup
cmd_setup() {
    log_header "${ROCKET} Setting up DearReader Environment"

    # Pre-flight checks
    log_subheader "Pre-flight Checks"

    if ! curl -s --connect-timeout 5 --max-time 10 https://www.google.com >/dev/null 2>&1 && \
       ! curl -s --connect-timeout 5 --max-time 10 https://www.cloudflare.com >/dev/null 2>&1; then
        log_error "No internet connection detected. Please check your network."
        exit 1
    fi
    log_success "Internet connection verified"

    if [[ "$OSTYPE" != "msys" && "$OSTYPE" != "win32" ]]; then
        local available_space
        available_space=$(df -BG . | awk 'NR==2 {print $4}' | sed 's/G//')
        if [ "$available_space" -lt 2 ]; then
            log_error "Insufficient disk space. Need at least 2GB free."
            exit 1
        fi
        log_success "Sufficient disk space available"
    fi

    # Check prerequisites
    log_subheader "Checking Prerequisites"
    check_docker

    if ! command -v node >/dev/null 2>&1; then
        log_error "Node.js is not installed. Please install Node.js 18+ from https://nodejs.org"
        exit 1
    fi

    node_version=$(node -v 2>/dev/null | sed 's/^v//')
    node_major_version=$(echo "${node_version%%.*}")
    if [ "$node_major_version" -lt 18 ]; then
        log_warn "Node.js version $node_version detected. Recommended: 18+"
    else
        log_success "Node.js environment ready"
    fi

    log_subheader "Checking Optional Dependencies"
    case "$OSTYPE" in
      linux-gnu*)
        check_dependency "tesseract" "Tesseract OCR" "sudo apt-get update && sudo apt-get install -y tesseract-ocr"
        check_dependency "chromium-browser" "Chromium" "sudo apt-get update && sudo apt-get install -y chromium-browser"
        ;;
      darwin*)
        check_dependency "tesseract" "Tesseract OCR" "brew install tesseract"
        check_dependency "chromium" "Chromium" "brew install --cask chromium"
        ;;
      msys*|win32*)
        log_warn "On Windows, please manually install Tesseract OCR and ensure it's in your PATH."
        log_info "Puppeteer will download its own Chromium browser on Windows."
        ;;
       *)
        log_warn "Could not determine OS for optional dependency checks. Please install Tesseract and Chromium manually if needed."
        ;;
    esac


    if ! command -v uv >/dev/null 2>&1; then
        log_warn "uv not found. Installing uv for faster Python package management..."
        if ! (curl -LsSf https://astral.sh/uv/install.sh | sh); then
            log_warn "Failed to install uv automatically. Will use pip as fallback."
            USE_UV=false
        else
            export PATH="$HOME/.cargo/bin:$PATH"
            if ! command -v uv >/dev/null 2>&1; then
                log_warn "uv installed, but not found in PATH. Please restart your terminal or source your shell profile."
                USE_UV=false
            else
                log_success "uv installed successfully."
                USE_UV=true
            fi
        fi
    else
        log_success "uv is already installed"
        USE_UV=true
    fi

    log_subheader "Creating Project Structure"
    run_cmd "Creating directories" mkdir -p storage logs docker js/node_modules

    if [ -f "config.yaml" ]; then
        log_info "config.yaml already exists."
    else
        run_cmd "Creating default config.yaml" cp config.example.yaml config.yaml
    fi

    if [ ! -f "enabled_tasks.txt" ]; then
        run_cmd "Creating enabled_tasks.txt" touch enabled_tasks.txt
    fi

    log_subheader "Building Docker Images"
    run_cmd "Building Docker images" docker-compose build

    log_subheader "Setting up Python Environment"
    if [ "$USE_UV" = true ]; then
        run_cmd "Creating Python virtual environment with uv" uv venv --clear
    else
        run_cmd "Creating Python virtual environment with venv" python -m venv .venv
    fi

    log_success "Python virtual environment ready"

    if [ "$USE_UV" = true ]; then
        run_cmd "Installing Python dependencies with uv" uv pip install -r py/requirements.txt
    else
        source .venv/bin/activate || source .venv/Scripts/activate
        run_cmd "Installing Python dependencies with pip" pip install -r py/requirements.txt
    fi

    log_subheader "Setting up Node.js Environment"
    run_cmd "Installing Node.js dependencies" npm install --prefix js

    log_success "${SPARKLES} Setup complete!"
    echo -e "\n${GREEN}You're all set! Next steps:${NC}"
    echo -e "  ${CYAN}1.${NC} Start development: ${WHITE}./dearreader dev${NC}"
    echo -e "  ${CYAN}2.${NC} Run tests: ${WHITE}./dearreader test${NC}"
    echo -e "  ${CYAN}3.${NC} Open browser: ${WHITE}http://localhost:3001${NC}"
}

# Development command
cmd_dev() {
    log_header "${GEAR} Starting Development Environment"
    check_docker

    run_cmd "Cleaning up existing containers" docker-compose down --remove-orphans
    log_info "Running end-to-end tests before starting..."

    if cmd_test "e2e"; then
        log_success "End-to-end tests passed! Starting development environment..."
    else
        log_error "End-to-end tests failed."
        if [ "$FORCE" != true ]; then
            log_error "Exiting due to test failures. Use --force to continue anyway."
            exit 1
        fi
        log_warn "Continuing despite test failures (--force used)"
    fi

    run_cmd "Starting development services" docker-compose --profile dev up --build -d

    log_success "Development environment started!"
    echo -e "\n${GREEN}${HEART} Services are running:${NC}"
    echo -e "  ${CYAN}•${NC} Web Interface: ${WHITE}http://localhost:3001${NC}"
    echo -e "  ${CYAN}•${NC} API Endpoint: ${WHITE}http://localhost:3001/https://www.ala.org${NC}"
    echo -e "  ${CYAN}•${NC} View logs: ${WHITE}./dearreader logs --follow${NC}"

    if [ "$FOLLOW" = true ]; then
        cmd_logs
    fi
}

# Test command
cmd_test() {
    local test_type="${1:-all}"
    log_header "${TEST} Running Tests ($test_type)"

    # Count test types and number of tests for each
    local test_types=("js" "python" "e2e" "pipeline")
    local total_types=0
    local js_count=0
    local python_count=0
    local e2e_count=0
    local pipeline_count=0

    # Count JS tests (count actual test cases, not just files)
    if [ -d "js/src" ]; then
        if command -v bc >/dev/null 2>&1; then
            js_count=$(find js/src -name "*.test.ts" -exec grep -c "it(" {} \; | paste -sd+ | bc 2>/dev/null)
        else
            # Fallback if bc is not available
            js_count=$(find js/src -name "*.test.ts" -exec grep -c "it(" {} \; | awk '{sum += $1} END {print sum}')
        fi
        if ! [[ "$js_count" =~ ^[0-9]+$ ]] || [ -z "$js_count" ]; then
            js_count=0
        fi
    else
        js_count=0
    fi

    # Count Python tests (count actual test functions, not just files)
    if [ -d "py/tests" ]; then
        if command -v bc >/dev/null 2>&1; then
            python_count=$(find py/tests -name "test_*.py" -exec grep -c "def test_" {} \; | paste -sd+ | bc 2>/dev/null)
        else
            # Fallback if bc is not available
            python_count=$(find py/tests -name "test_*.py" -exec grep -c "def test_" {} \; | awk '{sum += $1} END {print sum}')
        fi
        if ! [[ "$python_count" =~ ^[0-9]+$ ]] || [ -z "$python_count" ]; then
            python_count=0
        fi
    else
        python_count=0
    fi

    # Count E2E tests
    if [ -f "./scripts/e2e-test.sh" ]; then
        e2e_count=$(grep -c "^pytest " ./scripts/e2e-test.sh 2>/dev/null | tr -d '[:space:]')
        if ! [[ "$e2e_count" =~ ^[0-9]+$ ]] || [ -z "$e2e_count" ]; then
            e2e_count=0
        fi
    else
        e2e_count=0
    fi

    # Count Pipeline tests (count actual test calls)
    if [ -f "js/src/test-pipeline.js" ]; then
        pipeline_count=$(grep -c "logTest" js/src/test-pipeline.js 2>/dev/null | tr -d '[:space:]')
        if ! [[ "$pipeline_count" =~ ^[0-9]+$ ]] || [ -z "$pipeline_count" ]; then
            pipeline_count=0
        fi
    else
        pipeline_count=0
    fi

    # Count enabled test types
    for t in "${test_types[@]}"; do
        case "$t" in
            js) [ "$js_count" -gt 0 ] && total_types=$((total_types+1)) ;;
            python) [ "$python_count" -gt 0 ] && total_types=$((total_types+1)) ;;
            e2e) [ "$e2e_count" -gt 0 ] && total_types=$((total_types+1)) ;;
            pipeline) [ "$pipeline_count" -gt 0 ] && total_types=$((total_types+1)) ;;
        esac
    done

    # Display test counts in a delightful way
    echo -e "\n${BOLD}${CYAN}📊 Test Suite Overview${NC}"
    echo -e "${CYAN}──────────────────────────────────────────────${NC}"
    echo -e "${GREEN}JavaScript:${NC}   $(printf '%-3s' "$js_count") $(yes '🟩' | head -n "$js_count" | tr -d '\n')"
    echo -e "${YELLOW}Python:${NC}       $(printf '%-3s' "$python_count") $(yes '🟨' | head -n "$python_count" | tr -d '\n')"
    echo -e "${BLUE}End-to-End:${NC}   $(printf '%-3s' "$e2e_count") $(yes '🟦' | head -n "$e2e_count" | tr -d '\n')"
    echo -e "${MAGENTA}Pipeline:${NC}     $(printf '%-3s' "$pipeline_count") $(yes '🟪' | head -n "$pipeline_count" | tr -d '\n')"
    echo -e "${CYAN}──────────────────────────────────────────────${NC}"
    echo -e "${BOLD}Test types enabled:${NC} $total_types\n"

    run_test() {
        local test_name="$1"
        shift
        log_subheader "Running $test_name Tests"
        if run_cmd "Running $test_name tests" "$@"; then
            log_success "$test_name tests passed"
            return 0
        else
            log_error "$test_name tests failed"
            echo -e "${RED}Details of failure:${NC}"
            # Show output of the failed command for debugging
            "$@"
            [ "$FORCE" != true ] && exit 1
            return 1
        fi
    }

    case "$test_type" in
        js)
            run_test "JavaScript" docker-compose --profile dev run --rm js-test
            ;;
        python)
            if [ "$USE_UV" = true ]; then
                run_test "Python" uv run python3 -m pytest py/tests --verbose
            else
                run_test "Python" bash -c "source .venv/bin/activate || source .venv/Scripts/activate; python3 -m pytest py/tests --verbose"
            fi
            ;;
        e2e)
            run_test "End-to-End" ./scripts/e2e-test.sh
            ;;
        pipeline)
            if [ ! -f "js/src/test-pipeline.js" ]; then
                log_error "Pipeline test runner script not found at js/src/test-pipeline.js"
                log_info "Please ensure this file exists in your project and is checked into version control."
                exit 1
            fi
            run_test "Pipeline" node js/src/test-pipeline.js
            ;;
        all)
            cmd_test js
            cmd_test python
            cmd_test e2e
            cmd_test pipeline
            log_success "All tests completed!"
            ;;
        *)
            log_error "Unknown test type: $test_type"
            echo "Available: js, python, e2e, pipeline, all"
            exit 1
            ;;
    esac
}

# Run command
cmd_run() {
    local env="${1:-dev}"
    log_header "${ROCKET} Starting $env Environment"
    check_docker

    case "$env" in
        dev)
            run_cmd "Cleaning up containers" docker-compose down --remove-orphans
            run_cmd "Starting development environment" docker-compose --profile dev up --build -d
            log_success "Development environment started"
            ;;
        prod)
            run_cmd "Cleaning up containers" docker-compose down --remove-orphans
            run_cmd "Starting production environment" docker-compose --profile prod up --build -d
            log_success "Production environment started"
            ;;
        *)
            log_error "Unknown environment: $env"
            echo "Available: dev, prod"
            exit 1
            ;;
    esac
}

# Stop command
cmd_stop() {
    log_header "${STOP} Stopping Services"
    run_cmd "Stopping all containers" docker-compose down --remove-orphans
    log_success "All services stopped"
}

# Status command
cmd_status() {
    log_header "${INFO} System Status"
    echo -e "\n${BOLD}Docker Services:${NC}"
    docker-compose ps

    echo -e "\n${BOLD}API Health Check:${NC}"
    if curl -s --fail http://localhost:3001/health >/dev/null 2>&1; then
        log_success "API is healthy"
    else
        log_warn "API not responding (is the dev environment running?)"
    fi
}

# Logs command
cmd_logs() {
    log_header "${BOOK} Service Logs"
    if [ "$FOLLOW" = true ]; then
        docker-compose logs -f
    else
        docker-compose logs
    fi
}

# Clean command
cmd_clean() {
    log_header "${WARNING} Cleaning Up"
    log_warn "This will remove all containers, volumes, and local logs/storage."
    read -p "Are you sure? (y/N): " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        run_cmd "Stopping containers" docker-compose down --volumes --remove-orphans
        run_cmd "Cleaning Docker system" docker system prune -f
        run_cmd "Cleaning local storage and logs" rm -rf storage/* logs/*
        log_success "Cleanup complete"
    else
        log_info "Cleanup cancelled"
    fi
}


# Create a dedicated script to handle task management logic.
create_task_script_if_not_exists() {
    local script_path="js/src/manage-tasks.js"
    if [ -f "$script_path" ]; then
        return
    fi
    log_info "Creating helper script for task management at $script_path..."
    cat > "$script_path" << 'EOF'
const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

const configPath = path.join(__dirname, '../../crawl_pipeline.yaml');
const enabledTasksPath = path.join(__dirname, '../../enabled_tasks.txt');
const command = process.argv[2];
const taskName = process.argv[3];

function loadConfig() {
    if (!fs.existsSync(configPath)) {
        console.error('Error: crawl_pipeline.yaml not found.');
        process.exit(1);
    }
    return yaml.load(fs.readFileSync(configPath, 'utf8'));
}

function getAllTasks(config) {
    const tasks = {};
    const extract = (taskGroup, type) => {
        if (!taskGroup) return;
        for (const [key, value] of Object.entries(taskGroup)) {
            tasks[key] = { name: value.name || 'Unnamed', type };
        }
    };
    extract(config.pipeline_tests?.stage_tests, 'Stage');
    extract(config.pipeline_tests?.pipeline_tests, 'Pipeline');
    extract(config.pipeline_tests?.ai_task_tests, 'AI');
    return tasks;
}

function listTasks() {
    const config = loadConfig();
    const allTasks = getAllTasks(config);
    if (Object.keys(allTasks).length === 0) {
        console.log('No tasks found in pipeline configuration.');
        return;
    }
    console.log('📋 Available Pipeline Tasks:');
    for (const [key, value] of Object.entries(allTasks)) {
        console.log(`  • ${key} (${value.type}): ${value.name}`);
    }
}

function showStatus() {
    const config = loadConfig();
    const allTasks = getAllTasks(config);
    const enabledTasks = new Set(
        fs.existsSync(enabledTasksPath)
            ? fs.readFileSync(enabledTasksPath, 'utf8').split('\n').filter(Boolean)
            : []
    );
    console.log('📋 Pipeline Task Status:');
    for (const [key, value] of Object.entries(allTasks)) {
        const status = enabledTasks.has(key) ? '✅ Enabled' : '❌ Disabled';
        console.log(`  • ${key} (${value.type}): [${status}]`);
    }
}

function enableTask(task) {
    const allTasks = getAllTasks(loadConfig());
    if (!allTasks[task]) {
        console.error(`Error: Task '${task}' not found.`);
        return;
    }
    const enabledTasks = fs.readFileSync(enabledTasksPath, 'utf8');
    if (enabledTasks.includes(task)) {
        console.warn(`Warning: Task '${task}' is already enabled.`);
    } else {
        fs.appendFileSync(enabledTasksPath, `${task}\n`);
        console.log(`Success: Task '${task}' enabled.`);
    }
}

function disableTask(task) {
    if (!fs.existsSync(enabledTasksPath)) return;
    let enabledTasks = fs.readFileSync(enabledTasksPath, 'utf8').split('\n');
    if (!enabledTasks.includes(task)) {
        console.warn(`Warning: Task '${task}' is not currently enabled.`);
        return;
    }
    const updatedTasks = enabledTasks.filter(t => t !== task && t).join('\n') + '\n';
    fs.writeFileSync(enabledTasksPath, updatedTasks);
    console.log(`Success: Task '${task}' disabled.`);
}

switch (command) {
    case 'list': listTasks(); break;
    case 'status': showStatus(); break;
    case 'enable': enableTask(taskName); break;
    case 'disable': disableTask(taskName); break;
    default: console.error(`Unknown command: ${command}`);
}
EOF
}

# Task command
cmd_task() {
    local subcommand="${1:-list}"
    local task_name="$2"
    log_header "${BOOK} Pipeline Tasks"

    create_task_script_if_not_exists

    if [ "$subcommand" = "enable" ] || [ "$subcommand" = "disable" ]; then
        if [ -z "$task_name" ]; then
            log_error "Task name is required for '$subcommand' command."
            echo "Usage: ./dearreader task $subcommand <task_name>"
            exit 1
        fi
    fi

    run_cmd "Running task command" node js/src/manage-tasks.js "$subcommand" "$task_name"
}

# API command
cmd_api() {
    local subcommand="${1:-test}"
    log_header "${INFO} API Management"

    case "$subcommand" in
        test)
            log_subheader "Testing API Endpoints"
            if curl -s --fail http://localhost:3001/health >/dev/null 2>&1; then
                log_success "API health check passed"
            else
                log_error "API health check failed"
                exit 1
            fi
            ;;
        *)
            log_error "Unknown API subcommand: $subcommand"
            echo "Available: test"
            exit 1
            ;;
    esac
}

# Migration command
cmd_migration() {
    log_header "Migration Guide"
    # This informational command is fine as is
    echo -e "  ${GREEN}${CHECK}${NC} ./dearreader script created and working"
    echo -e "  ${GREEN}${CHECK}${NC} All functionality from old scripts preserved"
    echo -e "  ${GREEN}${CHECK}${NC} Enhanced with new features (status, logs, api test)"
    # ... (rest of the help text from original script)
}

# Main logic
main() {
    local command="$1"
    # Allow running without a command to show help
    if [ -z "$command" ]; then
        show_help
        exit 0
    fi
    shift

    # Parse flags
    VERBOSE=false
    FORCE=false
    FOLLOW=false

    local args_without_flags=()
    for arg in "$@"; do
        case "$arg" in
            --verbose|-v) VERBOSE=true ;;
            --force|-f) FORCE=true ;;
            --follow|-F) FOLLOW=true ;;
            *) args_without_flags+=("$arg") ;;
        esac
    done
    set -- "${args_without_flags[@]}"

    case "$command" in
        setup|dev|test|run|stop|status|logs|clean|api|task|migration)
            "cmd_$command" "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            show_help
            exit 1
            ;;
    esac
}

# Run main with all arguments
main "$@"