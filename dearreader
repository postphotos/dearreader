#!/usr/bin/env bash

# DearReader - Unified Project Manager
# A delightful CLI for managing the DearReader web crawler

# Exit immediately if a command exits with a non-zero status.
set -e

# --- Portability Fix ---
# Get the directory where this script is located and navigate to project root.
# This approach is more portable than `readlink -f` which is not available on macOS by default.
SCRIPT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
PROJECT_ROOT="$SCRIPT_DIR"
cd "$PROJECT_ROOT"

# Global variable for uv usage
USE_UV=false

# Color and formatting constants
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Emoji constants
ROCKET="ğŸš€"
GEAR="âš™ï¸"
CHECK="âœ…"
CROSS="âŒ"
WARNING="âš ï¸"
INFO="â„¹ï¸"
BOOK="ğŸ“š"
DOCKER="ğŸ³"
PYTHON="ğŸ"
NODE="ğŸŸ¢"
TEST="ğŸ§ª"
STOP="ğŸ›‘"
SPARKLES="âœ¨"
HEART="â¤ï¸"

# Logging functions with colors and emojis
log_info() {
    echo -e "${BLUE}${INFO}${NC} $1"
}

log_success() {
    echo -e "${GREEN}${CHECK}${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}${WARNING}${NC} $1"
}

log_error() {
    echo -e "${RED}${CROSS}${NC} $1"
}

log_header() {
    echo -e "\n${MAGENTA}${BOLD}$1${NC}"
    echo -e "${MAGENTA}$(printf '%.0s=' {1..50})${NC}"
}

log_subheader() {
    echo -e "${CYAN}${BOLD}$1${NC}"
}

# Show beautiful help
show_help() {
    cat <<'EOF'

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                     ğŸ“š DearReader CLI                       â•‘
â•‘              Web Content Extraction Made Simple             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

USAGE:
    ./dearreader <command> [subcommand] [options]

COMMANDS:
    setup           ğŸ—ï¸  Set up development environment
    dev             ğŸš€  Start development environment
    test            ğŸ§ª  Run tests (js, python, e2e, pipeline, or all) - defaults to all
    run             â–¶ï¸   Start services (dev/prod)
    stop            ğŸ›‘  Stop all services
    status          ğŸ“Š  Show system status
    logs            ğŸ“  Show service logs
    clean           ğŸ§¹  Clean up containers and volumes
    migration       ğŸ“‹  Show migration status and tips
    task            ğŸ“‹  Manage pipeline tasks (list, status, enable, disable)

OPTIONS:
    --verbose|-v    Show detailed output
    --force|-f      Continue despite errors
    --follow|-F     Follow logs in real-time
    --requests|-r   Use real AI API calls instead of mock responses (pipeline tests only)

EXAMPLES:
    ./dearreader setup              # First-time setup
    ./dearreader dev                # Start development
    ./dearreader test               # Run all tests (default)
    ./dearreader test e2e           # Run end-to-end tests only
    ./dearreader test js            # Run JavaScript tests only
    ./dearreader test python        # Run Python tests only
    ./dearreader test pipeline      # Run pipeline tests only
    ./dearreader test pipeline --requests  # Run pipeline tests with real AI calls
    ./dearreader run prod           # Start production
    ./dearreader status             # Check system status
    ./dearreader api test           # Test API endpoints
    ./dearreader task list          # List all available pipeline tasks
    ./dearreader task status        # Show task status (enabled/disabled)
    ./dearreader task enable <task> # Enable a specific task
    ./dearreader task disable <task># Disable a specific task

URL EXAMPLES (when server is running):
    localhost:3000/default_html/https://example.com     # HTML with markdown
    localhost:3000/default_html_json/https://example.com # HTML to JSON
    localhost:3000/default_pdf/https://example.com/doc.pdf # PDF with OCR
    localhost:3000/json/https://example.com             # Legacy JSON format

QUICK START:
    1. ./scripts/quickstart.sh    # 1-click setup (fastest!)
    2. ./dearreader setup         # Manual setup
    3. ./dearreader dev           # Start development
    4. Open http://localhost:3001

EOF
}

# Check if Docker is available
check_docker() {
    if ! command -v docker >/dev/null 2>&1; then
        log_error "Docker is not installed or not in PATH"
        echo "Please install Docker: https://www.docker.com/get-started"
        exit 1
    fi

    if ! docker version >/dev/null 2>&1; then
        log_error "Docker daemon is not running"
        echo "Please start Docker and try again"
        exit 1
    fi

    if ! command -v docker-compose >/dev/null 2>&1; then
        log_error "Docker Compose is not installed"
        echo "Please install Docker Compose"
        exit 1
    fi
}

# Cross-platform command execution with better feedback and security.
run_cmd() {
    local description="$1"
    shift
    local cmd_str="$*"

    log_info "$description..."

    if [ "$VERBOSE" = true ]; then
        echo -e "${CYAN}  â””â”€ ${cmd_str}${NC}"
        # Execute with output visible
        "$@"
        return $?
    else
        # Execute and capture stderr on failure
        local stderr
        stderr=$("$@" 2>&1 >/dev/null)
        local exit_code=$?
        if [ $exit_code -ne 0 ]; then
            log_error "Failed: $description"
            echo -e "${RED}Error details:${NC}\n$stderr" >&2
            return $exit_code
        fi
    fi
}

# Checks for a command and provides installation instructions if missing.
check_dependency() {
    local cmd="$1"
    local package="$2"
    local instructions="$3"

    if ! command -v "$cmd" >/dev/null 2>&1; then
        log_warn "$package not found. This is required for some features."
        echo -e "${YELLOW}To install it, please run:${NC}"
        echo -e "  $instructions"
        return 1
    else
        log_success "$package is installed"
        return 0
    fi
}

# Setup command - comprehensive environment setup
cmd_setup() {
    log_header "${ROCKET} Setting up DearReader Environment"

    # Pre-flight checks
    log_subheader "Pre-flight Checks"

    if ! curl -s --connect-timeout 5 --max-time 10 https://www.google.com >/dev/null 2>&1 && \
       ! curl -s --connect-timeout 5 --max-time 10 https://www.cloudflare.com >/dev/null 2>&1; then
        log_error "No internet connection detected. Please check your network."
        exit 1
    fi
    log_success "Internet connection verified"

    if [[ "$OSTYPE" != "msys" && "$OSTYPE" != "win32" ]]; then
        local available_space
        available_space=$(df -BG . | awk 'NR==2 {print $4}' | sed 's/G//')
        if [ "$available_space" -lt 2 ]; then
            log_error "Insufficient disk space. Need at least 2GB free."
            exit 1
        fi
        log_success "Sufficient disk space available"
    fi

    # Check prerequisites
    log_subheader "Checking Prerequisites"
    check_docker

    if ! command -v node >/dev/null 2>&1; then
        log_error "Node.js is not installed. Please install Node.js 18+ from https://nodejs.org"
        exit 1
    fi

    node_version=$(node -v 2>/dev/null | sed 's/^v//')
    node_major_version=$(echo "${node_version%%.*}")
    if [ "$node_major_version" -lt 18 ]; then
        log_warn "Node.js version $node_version detected. Recommended: 18+"
    else
        log_success "Node.js environment ready"
    fi

    log_subheader "Checking Optional Dependencies"
    case "$OSTYPE" in
      linux-gnu*)
        check_dependency "tesseract" "Tesseract OCR" "sudo apt-get update && sudo apt-get install -y tesseract-ocr"
        check_dependency "chromium-browser" "Chromium" "sudo apt-get update && sudo apt-get install -y chromium-browser"
        ;;
      darwin*)
        check_dependency "tesseract" "Tesseract OCR" "brew install tesseract"
        check_dependency "chromium" "Chromium" "brew install --cask chromium"
        ;;
      msys*|win32*)
        log_warn "On Windows, please manually install Tesseract OCR and ensure it's in your PATH."
        log_info "Puppeteer will download its own Chromium browser on Windows."
        ;;
       *)
        log_warn "Could not determine OS for optional dependency checks. Please install Tesseract and Chromium manually if needed."
        ;;
    esac


    if ! command -v uv >/dev/null 2>&1; then
        log_warn "uv not found. Installing uv for faster Python package management..."
        if ! (curl -LsSf https://astral.sh/uv/install.sh | sh); then
            log_warn "Failed to install uv automatically. Will use pip as fallback."
            USE_UV=false
        else
            export PATH="$HOME/.cargo/bin:$PATH"
            if ! command -v uv >/dev/null 2>&1; then
                log_warn "uv installed, but not found in PATH. Please restart your terminal or source your shell profile."
                USE_UV=false
            else
                log_success "uv installed successfully."
                USE_UV=true
            fi
        fi
    else
        log_success "uv is already installed"
        USE_UV=true
    fi

    log_subheader "Creating Project Structure"
    run_cmd "Creating directories" mkdir -p storage logs docker js/node_modules

    if [ -f "config.yaml" ]; then
        log_info "config.yaml already exists."
    else
        run_cmd "Creating default config.yaml" cp config.example.yaml config.yaml
    fi

    if [ ! -f "enabled_tasks.txt" ]; then
        run_cmd "Creating enabled_tasks.txt" touch enabled_tasks.txt
    fi

    log_subheader "Building Docker Images"
    run_cmd "Building Docker images" docker-compose build

    log_subheader "Setting up Python Environment"
    if [ "$USE_UV" = true ]; then
        run_cmd "Creating Python virtual environment with uv" uv venv --clear
    else
        run_cmd "Creating Python virtual environment with venv" python -m venv .venv
    fi

    log_success "Python virtual environment ready"

    if [ "$USE_UV" = true ]; then
        run_cmd "Installing Python dependencies with uv" uv pip install -r py/requirements.txt
    else
        source .venv/bin/activate || source .venv/Scripts/activate
        run_cmd "Installing Python dependencies with pip" pip install -r py/requirements.txt
    fi

    log_subheader "Setting up Node.js Environment"
    run_cmd "Installing Node.js dependencies" npm install --prefix js

    log_success "${SPARKLES} Setup complete!"
    echo -e "\n${GREEN}You're all set! Next steps:${NC}"
    echo -e "  ${CYAN}1.${NC} Start development: ${WHITE}./dearreader dev${NC}"
    echo -e "  ${CYAN}2.${NC} Run tests: ${WHITE}./dearreader test${NC}"
    echo -e "  ${CYAN}3.${NC} Open browser: ${WHITE}http://localhost:3001${NC}"
}

# Development command
cmd_dev() {
    log_header "${GEAR} Starting Development Environment"
    check_docker

    run_cmd "Cleaning up existing containers" docker-compose down --remove-orphans
    log_info "Running end-to-end tests before starting..."

    # Run E2E tests - the function will handle exit codes properly
    cmd_test "e2e"

    # If we get here, tests passed (or --force was used)
    log_success "End-to-end tests passed! Starting development environment..."

    run_cmd "Starting development services" docker-compose --profile dev up --build -d

    log_success "Development environment started!"
    echo -e "\n${GREEN}${HEART} Services are running:${NC}"
    echo -e "  ${CYAN}â€¢${NC} Web Interface: ${WHITE}http://localhost:3001${NC}"
    echo -e "  ${CYAN}â€¢${NC} API Endpoint: ${WHITE}http://localhost:3001/https://www.ala.org${NC}"
    echo -e "  ${CYAN}â€¢${NC} View logs: ${WHITE}./dearreader logs --follow${NC}"

    if [ "$FOLLOW" = true ]; then
        cmd_logs
    fi
}

# Test command
cmd_test() {
    local test_type="${1:-all}"
    log_header "${TEST} Running Tests ($test_type)"

    # Count test types and number of tests for each
    local test_types=("js" "python" "e2e" "pipeline")
    local js_count=0
    local python_count=0
    local e2e_count=0
    local pipeline_count=0

    # Count JS tests (count actual test cases, not just files)
    if [ -d "js/src" ]; then
        if command -v bc >/dev/null 2>&1; then
            js_count=$(find js/src -name "*.test.ts" -exec grep -c "it(" {} \; | paste -sd+ | bc 2>/dev/null)
        else
            # Fallback if bc is not available
            js_count=$(find js/src -name "*.test.ts" -exec grep -c "it(" {} \; | awk '{sum += $1} END {print sum}')
        fi
        if ! [[ "$js_count" =~ ^[0-9]+$ ]] || [ -z "$js_count" ]; then
            js_count=0
        fi
    else
        js_count=0
    fi

    # Count Python tests (count actual test functions, not just files)
    if [ -d "py/tests" ]; then
        if command -v bc >/dev/null 2>&1; then
            python_count=$(find py/tests -name "test_*.py" -exec grep -c "def test_" {} \; | paste -sd+ | bc 2>/dev/null)
        else
            # Fallback if bc is not available
            python_count=$(find py/tests -name "test_*.py" -exec grep -c "def test_" {} \; | awk '{sum += $1} END {print sum}')
        fi
        if ! [[ "$python_count" =~ ^[0-9]+$ ]] || [ -z "$python_count" ]; then
            python_count=0
        fi
    else
        python_count=0
    fi

    # Count E2E tests
    if [ -f "./scripts/e2e-test.sh" ]; then
        e2e_count=$(grep -c "test_start " ./scripts/e2e-test.sh 2>/dev/null | tr -d '[:space:]')
        if ! [[ "$e2e_count" =~ ^[0-9]+$ ]] || [ -z "$e2e_count" ]; then
            e2e_count=0
        fi
    else
        e2e_count=0
    fi

    # Count Pipeline tests (count actual test calls)
    if [ -f "js/src/test-pipeline.js" ]; then
        pipeline_count=$(grep -c "logTest" js/src/test-pipeline.js 2>/dev/null | tr -d '[:space:]')
        if ! [[ "$pipeline_count" =~ ^[0-9]+$ ]] || [ -z "$pipeline_count" ]; then
            pipeline_count=0
        fi
    else
        pipeline_count=0
    fi

    # Display test counts based on what's being run
    if [ "$test_type" = "all" ]; then
        echo -e "\n${BOLD}${CYAN}ğŸ“Š Test Suite Overview${NC}"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
        [ "$js_count" -gt 0 ] && echo -e "${GREEN}JavaScript:${NC}   $(printf '%-3s' "$js_count") $(yes 'ğŸŸ©' | head -n "$js_count" | tr -d '\n')"
        [ "$python_count" -gt 0 ] && echo -e "${YELLOW}Python:${NC}       $(printf '%-3s' "$python_count") $(yes 'ğŸŸ¨' | head -n "$python_count" | tr -d '\n')"
        [ "$e2e_count" -gt 0 ] && echo -e "${BLUE}End-to-End:${NC}   $(printf '%-3s' "$e2e_count") $(yes 'ğŸŸ¦' | head -n "$e2e_count" | tr -d '\n')"
        [ "$pipeline_count" -gt 0 ] && echo -e "${MAGENTA}Pipeline:${NC}     $(printf '%-3s' "$pipeline_count") $(yes 'ğŸŸª' | head -n "$pipeline_count" | tr -d '\n')"
        echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}\n"
    else
        # Show only the specific test type being run
        case "$test_type" in
            js)
                [ "$js_count" -gt 0 ] && echo -e "\n${BOLD}${CYAN}ğŸ“Š JavaScript Tests${NC}"
                [ "$js_count" -gt 0 ] && echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
                [ "$js_count" -gt 0 ] && echo -e "${GREEN}JavaScript:${NC}   $(printf '%-3s' "$js_count") $(yes 'ğŸŸ©' | head -n "$js_count" | tr -d '\n')"
                [ "$js_count" -gt 0 ] && echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}\n"
                ;;
            python)
                [ "$python_count" -gt 0 ] && echo -e "\n${BOLD}${CYAN}ğŸ“Š Python Tests${NC}"
                [ "$python_count" -gt 0 ] && echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
                [ "$python_count" -gt 0 ] && echo -e "${YELLOW}Python:${NC}       $(printf '%-3s' "$python_count") $(yes 'ğŸŸ¨' | head -n "$python_count" | tr -d '\n')"
                [ "$python_count" -gt 0 ] && echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}\n"
                ;;
            e2e)
                [ "$e2e_count" -gt 0 ] && echo -e "\n${BOLD}${CYAN}ğŸ“Š End-to-End Tests${NC}"
                [ "$e2e_count" -gt 0 ] && echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
                [ "$e2e_count" -gt 0 ] && echo -e "${BLUE}End-to-End:${NC}   $(printf '%-3s' "$e2e_count") $(yes 'ğŸŸ¦' | head -n "$e2e_count" | tr -d '\n')"
                [ "$e2e_count" -gt 0 ] && echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}\n"
                ;;
            pipeline)
                [ "$pipeline_count" -gt 0 ] && echo -e "\n${BOLD}${CYAN}ğŸ“Š Pipeline Tests${NC}"
                [ "$pipeline_count" -gt 0 ] && echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
                [ "$pipeline_count" -gt 0 ] && echo -e "${MAGENTA}Pipeline:${NC}     $(printf '%-3s' "$pipeline_count") $(yes 'ğŸŸª' | head -n "$pipeline_count" | tr -d '\n')"
                [ "$pipeline_count" -gt 0 ] && echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}\n"
                ;;
        esac
    fi

    # Track test results
    local overall_success=true
    local test_results=()

    run_single_test() {
        local test_name="$1"
        local test_count="$2"
        local test_color="$3"
        local test_emoji="$4"
        shift 4
        local test_cmd="$*"

        echo -e "${BOLD}${test_color}Running $test_name Tests${NC}"

        # Show progress bar with pending tests
        echo -n "Progress: "
        for ((i=1; i<=test_count; i++)); do
            echo -n "${test_emoji}"
        done
        echo -n " "
        echo -ne "\rProgress: "

        # Run the test and capture output
        local test_output=""
        local test_exit_code=0

        if [ "$VERBOSE" = true ]; then
            # Show output in real-time
            if "$@"; then
                test_exit_code=0
            else
                test_exit_code=$?
            fi
        else
            # Capture output for later analysis
            test_output=$("$@" 2>&1)
            test_exit_code=$?
        fi

        # Check for warnings in output
        local has_warnings=false
        if echo "$test_output" | grep -qi "warn\|warning\|deprecated\|experimental" 2>/dev/null; then
            has_warnings=true
        fi

        # Update progress bar based on result
        if [ $test_exit_code -eq 0 ]; then
            # Success - show green boxes
            for ((i=1; i<=test_count; i++)); do
                echo -n "${GREEN}ğŸŸ©${NC}"
            done
            echo -e " ${GREEN}${CHECK} $test_name tests passed${NC}"
            if [ "$has_warnings" = true ]; then
                log_warn "$test_name tests passed with warnings"
                echo "$test_output" | grep -i "warn\|warning\|deprecated\|experimental" | head -3
            fi
            test_results+=("$test_name:PASS")
        else
            # Failure - show red boxes
            for ((i=1; i<=test_count; i++)); do
                echo -n "${RED}ğŸŸ¥${NC}"
            done
            echo -e " ${RED}${CROSS} $test_name tests failed${NC}"
            if [ "$VERBOSE" != true ]; then
                echo -e "${RED}Error details:${NC}"
                echo "$test_output" | head -10
                if [ $(echo "$test_output" | wc -l) -gt 10 ]; then
                    echo -e "${YELLOW}... (truncated, use --verbose for full output)${NC}"
                fi
            fi
            test_results+=("$test_name:FAIL")
            overall_success=false
        fi
        echo ""
    }

    case "$test_type" in
        js|python|e2e|pipeline|all)
            # Valid test types - continue processing
            ;;
        --help|-h|help)
            echo -e "\n${BOLD}${CYAN}ğŸ§ª Test Command Help${NC}"
            echo -e "${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
            echo -e "${WHITE}Usage:${NC} ./dearreader test [type] [options]"
            echo -e ""
            echo -e "${WHITE}Test Types:${NC}"
            echo -e "  ${GREEN}js${NC}        Run JavaScript tests only"
            echo -e "  ${YELLOW}python${NC}    Run Python tests only"
            echo -e "  ${BLUE}e2e${NC}       Run End-to-End tests only"
            echo -e "  ${MAGENTA}pipeline${NC}  Run Pipeline tests only"
            echo -e "  ${CYAN}all${NC}       Run all test types (default)"
            echo -e ""
            echo -e "${WHITE}Options:${NC}"
            echo -e "  ${WHITE}--verbose, -v${NC}  Show detailed test output"
            echo -e "  ${WHITE}--force, -f${NC}    Continue even if tests fail"
            echo -e "  ${WHITE}--requests, -r${NC} Use real AI API calls instead of mock responses (pipeline tests only)"
            echo -e "  ${WHITE}--help, -h${NC}     Show this help message"
            echo -e ""
            echo -e "${WHITE}Examples:${NC}"
            echo -e "  ${WHITE}./dearreader test${NC}              # Run all tests"
            echo -e "  ${WHITE}./dearreader test js${NC}           # Run only JS tests"
            echo -e "  ${WHITE}./dearreader test python --verbose${NC}  # Run Python tests with details"
            echo -e "  ${WHITE}./dearreader test pipeline --requests${NC}  # Run pipeline tests with real AI calls"
            echo -e "  ${WHITE}./dearreader test all --force${NC}  # Run all tests, don't stop on failures"
            exit 0
            ;;
        js)
            [ "$js_count" -gt 0 ] && run_single_test "JavaScript" "$js_count" "$GREEN" "ğŸŸ©" docker-compose --profile dev run --rm js-test
            ;;
        python)
            if [ "$USE_UV" = true ]; then
                [ "$python_count" -gt 0 ] && run_single_test "Python" "$python_count" "$YELLOW" "ğŸŸ¨" uv run python3 -m pytest py/tests --verbose
            else
                [ "$python_count" -gt 0 ] && run_single_test "Python" "$python_count" "$YELLOW" "ğŸŸ¨" bash -c "source .venv/bin/activate || source .venv/Scripts/activate; python3 -m pytest py/tests --verbose"
            fi
            ;;
        e2e)
            [ "$e2e_count" -gt 0 ] && run_single_test "End-to-End" "$e2e_count" "$BLUE" "ğŸŸ¦" ./scripts/e2e-test.sh
            ;;
        pipeline)
            if [ ! -f "js/src/test-pipeline.js" ]; then
                log_error "Pipeline test runner script not found at js/src/test-pipeline.js"
                log_info "Please ensure this file exists in your project and is checked into version control."
                overall_success=false
                test_results+=("Pipeline:FAIL")
            else
                [ "$pipeline_count" -gt 0 ] && run_single_test "Pipeline" "$pipeline_count" "$MAGENTA" "ğŸŸª" node js/src/test-pipeline.js
            fi
            ;;
        all)
            # Run all tests and track overall success
            [ "$js_count" -gt 0 ] && run_single_test "JavaScript" "$js_count" "$GREEN" "ğŸŸ©" docker-compose --profile dev run --rm js-test

            if [ "$USE_UV" = true ]; then
                [ "$python_count" -gt 0 ] && run_single_test "Python" "$python_count" "$YELLOW" "ğŸŸ¨" uv run python3 -m pytest py/tests --verbose
            else
                [ "$python_count" -gt 0 ] && run_single_test "Python" "$python_count" "$YELLOW" "ğŸŸ¨" bash -c "source .venv/bin/activate || source .venv/Scripts/activate; python3 -m pytest py/tests --verbose"
            fi

            [ "$e2e_count" -gt 0 ] && run_single_test "End-to-End" "$e2e_count" "$BLUE" "ğŸŸ¦" ./scripts/e2e-test.sh

            if [ ! -f "js/src/test-pipeline.js" ]; then
                log_error "Pipeline test runner script not found at js/src/test-pipeline.js"
                log_info "Please ensure this file exists in your project and is checked into version control."
                overall_success=false
                test_results+=("Pipeline:FAIL")
            else
                [ "$pipeline_count" -gt 0 ] && run_single_test "Pipeline" "$pipeline_count" "$MAGENTA" "ğŸŸª" node js/src/test-pipeline.js
            fi

            # Show final summary for "all" tests
            echo -e "\n${BOLD}${CYAN}ğŸ“Š Test Results Summary${NC}"
            echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
            for result in "${test_results[@]}"; do
                local test_name=$(echo "$result" | cut -d: -f1)
                local status=$(echo "$result" | cut -d: -f2)
                if [ "$status" = "PASS" ]; then
                    echo -e "${GREEN}${CHECK} $test_name${NC}"
                else
                    echo -e "${RED}${CROSS} $test_name${NC}"
                fi
            done
            echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"

            if [ "$overall_success" = true ]; then
                log_success "All tests completed successfully!"
            else
                log_error "Some tests failed!"
                if [ "$FORCE" != true ]; then
                    exit 1
                fi
            fi
            ;;
        *)
            log_error "Unknown test type: $test_type"
            echo "Available: js, python, e2e, pipeline, all"
            echo "Use './dearreader test --help' for more information"
            exit 1
            ;;
    esac

    # For individual test types, exit with error if they failed (unless --force is used)
    if [ "$test_type" != "all" ] && [ "$overall_success" = false ]; then
        if [ "$FORCE" != true ]; then
            exit 1
        fi
    fi
}

# Run command
cmd_run() {
    local env="${1:-dev}"
    log_header "${ROCKET} Starting $env Environment"
    check_docker

    case "$env" in
        dev)
            run_cmd "Cleaning up containers" docker-compose down --remove-orphans
            run_cmd "Starting development environment" docker-compose --profile dev up --build -d
            log_success "Development environment started"
            ;;
        prod)
            run_cmd "Cleaning up containers" docker-compose down --remove-orphans
            run_cmd "Starting production environment" docker-compose --profile prod up --build -d
            log_success "Production environment started"
            ;;
        *)
            log_error "Unknown environment: $env"
            echo "Available: dev, prod"
            exit 1
            ;;
    esac
}

# Stop command
cmd_stop() {
    log_header "${STOP} Stopping Services"
    run_cmd "Stopping all containers" docker-compose down --remove-orphans
    log_success "All services stopped"
}

# Status command
cmd_status() {
    log_header "${INFO} System Status"
    echo -e "\n${BOLD}Docker Services:${NC}"
    docker-compose ps

    echo -e "\n${BOLD}API Health Check:${NC}"
    if curl -s --fail http://localhost:3001/health >/dev/null 2>&1; then
        log_success "API is healthy"
    else
        log_warn "API not responding (is the dev environment running?)"
    fi
}

# Logs command
cmd_logs() {
    log_header "${BOOK} Service Logs"
    if [ "$FOLLOW" = true ]; then
        docker-compose logs -f
    else
        docker-compose logs
    fi
}

# Clean command
cmd_clean() {
    log_header "${WARNING} Cleaning Up"
    log_warn "This will remove all containers, volumes, and local logs/storage."
    read -p "Are you sure? (y/N): " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        run_cmd "Stopping containers" docker-compose down --volumes --remove-orphans
        run_cmd "Cleaning Docker system" docker system prune -f
        run_cmd "Cleaning local storage and logs" rm -rf storage/* logs/*
        log_success "Cleanup complete"
    else
        log_info "Cleanup cancelled"
    fi
}


# Create a dedicated script to handle task management logic.
create_task_script_if_not_exists() {
    local script_path="js/src/manage-tasks.js"
    if [ -f "$script_path" ]; then
        return
    fi
    log_info "Creating helper script for task management at $script_path..."
    cat > "$script_path" << 'EOF'
const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

const configPath = path.join(__dirname, '../../crawl_pipeline.yaml');
const enabledTasksPath = path.join(__dirname, '../../enabled_tasks.txt');
const command = process.argv[2];
const taskName = process.argv[3];

function loadConfig() {
    if (!fs.existsSync(configPath)) {
        console.error('Error: crawl_pipeline.yaml not found.');
        process.exit(1);
    }
    return yaml.load(fs.readFileSync(configPath, 'utf8'));
}

function getAllTasks(config) {
    const tasks = {};
    const extract = (taskGroup, type) => {
        if (!taskGroup) return;
        for (const [key, value] of Object.entries(taskGroup)) {
            tasks[key] = { name: value.name || 'Unnamed', type };
        }
    };
    extract(config.pipeline_tests?.stage_tests, 'Stage');
    extract(config.pipeline_tests?.pipeline_tests, 'Pipeline');
    extract(config.pipeline_tests?.ai_task_tests, 'AI');
    return tasks;
}

function listTasks() {
    const config = loadConfig();
    const allTasks = getAllTasks(config);
    if (Object.keys(allTasks).length === 0) {
        console.log('No tasks found in pipeline configuration.');
        return;
    }
    console.log('ğŸ“‹ Available Pipeline Tasks:');
    for (const [key, value] of Object.entries(allTasks)) {
        console.log(`  â€¢ ${key} (${value.type}): ${value.name}`);
    }
}

function showStatus() {
    const config = loadConfig();
    const allTasks = getAllTasks(config);
    const enabledTasks = new Set(
        fs.existsSync(enabledTasksPath)
            ? fs.readFileSync(enabledTasksPath, 'utf8').split('\n').filter(Boolean)
            : []
    );
    console.log('ğŸ“‹ Pipeline Task Status:');
    for (const [key, value] of Object.entries(allTasks)) {
        const status = enabledTasks.has(key) ? 'âœ… Enabled' : 'âŒ Disabled';
        console.log(`  â€¢ ${key} (${value.type}): [${status}]`);
    }
}

function enableTask(task) {
    const allTasks = getAllTasks(loadConfig());
    if (!allTasks[task]) {
        console.error(`Error: Task '${task}' not found.`);
        return;
    }
    const enabledTasks = fs.readFileSync(enabledTasksPath, 'utf8');
    if (enabledTasks.includes(task)) {
        console.warn(`Warning: Task '${task}' is already enabled.`);
    } else {
        fs.appendFileSync(enabledTasksPath, `${task}\n`);
        console.log(`Success: Task '${task}' enabled.`);
    }
}

function disableTask(task) {
    if (!fs.existsSync(enabledTasksPath)) return;
    let enabledTasks = fs.readFileSync(enabledTasksPath, 'utf8').split('\n');
    if (!enabledTasks.includes(task)) {
        console.warn(`Warning: Task '${task}' is not currently enabled.`);
        return;
    }
    const updatedTasks = enabledTasks.filter(t => t !== task && t).join('\n') + '\n';
    fs.writeFileSync(enabledTasksPath, updatedTasks);
    console.log(`Success: Task '${task}' disabled.`);
}

switch (command) {
    case 'list': listTasks(); break;
    case 'status': showStatus(); break;
    case 'enable': enableTask(taskName); break;
    case 'disable': disableTask(taskName); break;
    default: console.error(`Unknown command: ${command}`);
}
EOF
}

# Task command
cmd_task() {
    local subcommand="${1:-list}"
    local task_name="$2"
    log_header "${BOOK} Pipeline Tasks"

    create_task_script_if_not_exists

    if [ "$subcommand" = "enable" ] || [ "$subcommand" = "disable" ]; then
        if [ -z "$task_name" ]; then
            log_error "Task name is required for '$subcommand' command."
            echo "Usage: ./dearreader task $subcommand <task_name>"
            exit 1
        fi
    fi

    run_cmd "Running task command" node js/src/manage-tasks.js "$subcommand" "$task_name"
}

# API command
cmd_api() {
    local subcommand="${1:-test}"
    log_header "${INFO} API Management"

    case "$subcommand" in
        test)
            log_subheader "Testing API Endpoints"
            if curl -s --fail http://localhost:3001/health >/dev/null 2>&1; then
                log_success "API health check passed"
            else
                log_error "API health check failed"
                exit 1
            fi
            ;;
        *)
            log_error "Unknown API subcommand: $subcommand"
            echo "Available: test"
            exit 1
            ;;
    esac
}

# Migration command
cmd_migration() {
    log_header "Migration Guide"
    # This informational command is fine as is
    echo -e "  ${GREEN}${CHECK}${NC} ./dearreader script created and working"
    echo -e "  ${GREEN}${CHECK}${NC} All functionality from old scripts preserved"
    echo -e "  ${GREEN}${CHECK}${NC} Enhanced with new features (status, logs, api test)"
    # ... (rest of the help text from original script)
}

# Main logic
main() {
    local command="$1"
    # Allow running without a command to show help
    if [ -z "$command" ]; then
        show_help
        exit 0
    fi
    shift

    # Parse flags
    VERBOSE=false
    FORCE=false
    FOLLOW=false

    local args_without_flags=()
    for arg in "$@"; do
        case "$arg" in
            --verbose|-v) VERBOSE=true ;;
            --force|-f) FORCE=true ;;
            --follow|-F) FOLLOW=true ;;
            *) args_without_flags+=("$arg") ;;
        esac
    done
    set -- "${args_without_flags[@]}"

    case "$command" in
        setup|dev|test|run|stop|status|logs|clean|api|task|migration)
            "cmd_$command" "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "Unknown command: $command"
            echo
            show_help
            exit 1
            ;;
    esac
}

# Run main with all arguments
main "$@"