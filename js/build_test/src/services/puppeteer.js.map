{
  "version": 3,
  "sources": ["../../../src/services/puppeteer.ts"],
  "sourcesContent": ["import os from 'os';\nimport fs from 'fs';\nimport { container, singleton } from 'tsyringe';\nimport { AsyncService, Defer, marshalErrorLike, delay, maxConcurrency } from 'civkit';\nimport { Logger } from '../shared/index.js';\nimport { createRequire } from 'module';\n\nconst nodeRequire = createRequire(import.meta.url);\n\nimport type { Browser, Page, BrowserContext } from 'puppeteer';\n\n// Import fetch conditionally - use native fetch in Node 18+\nconst fetch = globalThis.fetch;\n\nlet puppeteerCore: any;\nlet addExtra: any;\n\nif (process.env.USE_PUPPETEER_MOCK === 'true') {\n    console.log('\uD83D\uDD27 Using Puppeteer mock implementation');\n    // Dynamic runtime import so TypeScript does not treat test files as part of production build\n    const mockPath = new URL('../../test/mock-puppeteer.js', import.meta.url).href;\n    const { mockPuppeteer, mockAddExtra } = await import(mockPath);\n    puppeteerCore = mockPuppeteer;\n    addExtra = mockAddExtra;\n} else {\n  puppeteerCore = await import('puppeteer');\n  const puppeteerExtra = await import('puppeteer-extra');\n  addExtra = puppeteerExtra.addExtra;\n}\n\n// Define CookieParam type since it's not exported from puppeteer\nexport interface CookieParam {\n    name: string;\n    value: string;\n    url?: string;\n    domain?: string;\n    path?: string;\n    secure?: boolean;\n    httpOnly?: boolean;\n    sameSite?: 'Strict' | 'Lax' | 'None';\n    expires?: number;\n}\n\nimport puppeteerPageProxy from 'puppeteer-extra-plugin-page-proxy';\nimport { ServiceCrashedError } from '../shared/errors.js';\nimport { parse as tldParse } from 'tldts';\nimport puppeteerStealth from 'puppeteer-extra-plugin-stealth';\n\n// Queue for managing concurrent requests\ninterface QueuedRequest {\n    resolve: (value: Page) => void;\n    reject: (error: any) => void;\n    priority: number;\n    timestamp: number;\n}\n\n// Page wrapper with context tracking\ninterface ManagedPage {\n    page: Page;\n    context: BrowserContext;\n    sn: number;\n    createdAt: number;\n    inUse: boolean;\n    lastUsed: number;\n}\n\n// Add this new function for cookie validation\nconst validateCookie = (cookie: CookieParam) => {\n    const requiredFields = ['name', 'value'];\n    for (const field of requiredFields) {\n        if (!(field in cookie)) {\n            throw new Error(`Cookie is missing required field: ${field}`);\n        }\n    }\n};\n\nconst READABILITY_JS = fs.readFileSync(nodeRequire.resolve('@mozilla/readability/Readability.js'), 'utf-8');\n\n\nexport interface ImgBrief {\n    src: string;\n    loaded?: boolean;\n    width?: number;\n    height?: number;\n    naturalWidth?: number;\n    naturalHeight?: number;\n    alt?: string;\n}\n\nexport interface ReadabilityParsed {\n    title: string;\n    content: string;\n    textContent: string;\n    length: number;\n    excerpt: string;\n    byline: string;\n    dir: string;\n    siteName: string;\n    lang: string;\n    publishedTime: string;\n}\n\nexport interface PageSnapshot {\n    title: string;\n    href: string;\n    rebase?: string;\n    html: string;\n    text: string;\n    parsed?: Partial<ReadabilityParsed> | null;\n    screenshot?: Buffer;\n    pageshot?: Buffer;\n    imgs?: ImgBrief[];\n    pdfs?: string[];\n    maxElemDepth?: number;\n    elemCount?: number;\n    childFrames?: PageSnapshot[];\n    error?: string;\n}\n\nexport interface ExtendedSnapshot extends PageSnapshot {\n    links: { [url: string]: string; };\n    imgs: ImgBrief[];\n}\n\nexport interface ScrappingOptions {\n    proxyUrl?: string;\n    cookies?: CookieParam[];\n    favorScreenshot?: boolean;\n    waitForSelector?: string | string[];\n    minIntervalMs?: number;\n    overrideUserAgent?: string;\n    timeoutMs?: number;\n    viewportWidth?: number;\n    viewportHeight?: number;\n    fullPage?: boolean;\n}\n\nconst puppeteer = addExtra(puppeteerCore);\n\npuppeteer.use(puppeteerStealth());\npuppeteer.use(puppeteerPageProxy({\n    interceptResolutionPriority: 1,\n}));\n\nconst SCRIPT_TO_INJECT_INTO_FRAME = `\n${READABILITY_JS}\n\nfunction briefImgs(elem) {\n    const imageTags = Array.from((elem || document).querySelectorAll('img[src],img[data-src]'));\n\n    return imageTags.map((x)=> {\n        let linkPreferredSrc = x.src;\n        if (linkPreferredSrc.startsWith('data:')) {\n            if (typeof x.dataset?.src === 'string' && !x.dataset.src.startsWith('data:')) {\n                linkPreferredSrc = x.dataset.src;\n            }\n        }\n\n        return {\n            src: new URL(linkPreferredSrc, document.baseURI).toString(),\n            loaded: x.complete,\n            width: x.width,\n            height: x.height,\n            naturalWidth: x.naturalWidth,\n            naturalHeight: x.naturalHeight,\n            alt: x.alt || x.title,\n        };\n    });\n}\nfunction briefPDFs() {\n    const pdfTags = Array.from(document.querySelectorAll('embed[type=\"application/pdf\"]'));\n\n    return pdfTags.map((x)=> {\n        return x.src === 'about:blank' ? document.location.href : x.src;\n    });\n}\nfunction getMaxDepthAndCountUsingTreeWalker(root) {\n  let maxDepth = 0;\n  let currentDepth = 0;\n  let elementCount = 0;\n\n  const treeWalker = document.createTreeWalker(\n    root,\n    NodeFilter.SHOW_ELEMENT,\n    (node) => {\n      const nodeName = node.nodeName.toLowerCase();\n      return (nodeName === 'svg') ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;\n    },\n    false\n  );\n\n  while (true) {\n    maxDepth = Math.max(maxDepth, currentDepth);\n    elementCount++; // Increment the count for the current node\n\n    if (treeWalker.firstChild()) {\n      currentDepth++;\n    } else {\n      while (!treeWalker.nextSibling() && currentDepth > 0) {\n        treeWalker.parentNode();\n        currentDepth--;\n      }\n\n      if (currentDepth <= 0) {\n        break;\n      }\n    }\n  }\n\n  return {\n    maxDepth: maxDepth + 1,\n    elementCount: elementCount\n  };\n}\n\nfunction giveSnapshot(stopActiveSnapshot) {\n    if (stopActiveSnapshot) {\n        window.haltSnapshot = true;\n    }\n    let parsed;\n    try {\n        parsed = new Readability(document.cloneNode(true)).parse();\n    } catch (err) {\n        void 0;\n    }\n    const domAnalysis = getMaxDepthAndCountUsingTreeWalker(document.documentElement);\n    const r = {\n        title: document.title,\n        href: document.location.href,\n        html: document.documentElement?.outerHTML,\n        text: document.body?.innerText,\n        parsed: parsed,\n        imgs: [],\n        pdfs: briefPDFs(),\n        maxElemDepth: domAnalysis.maxDepth,\n        elemCount: domAnalysis.elementCount,\n    };\n    if (document.baseURI !== r.href) {\n        r.rebase = document.baseURI;\n    }\n    if (parsed && parsed.content) {\n        const elem = document.createElement('div');\n        elem.innerHTML = parsed.content;\n        r.imgs = briefImgs(elem);\n    } else {\n        const allImgs = briefImgs();\n        if (allImgs.length === 1) {\n            r.imgs = allImgs;\n        }\n    }\n\n    return r;\n}\n`;\n\n@singleton()\nexport class PuppeteerControl extends AsyncService {\n\n    _sn = 0;\n    browser!: Browser;\n    logger = new Logger('PuppeteerControl'); // Renamed for clarity\n\n    private __healthCheckInterval?: NodeJS.Timeout;\n    private __cleanupInterval?: NodeJS.Timeout;\n    private __emergencyCleanupInterval?: NodeJS.Timeout;\n    private __resourceMonitorInterval?: NodeJS.Timeout;\n\n    // Resource tracking for leak prevention\n    private startTime = Date.now();\n    private maxLifetime = 10 * 60 * 1000; // 10 minutes max lifetime in tests\n    private isClosing = false;\n\n    // New queue-based system\n    private requestQueue: QueuedRequest[] = [];\n    private pagePool: ManagedPage[] = [];\n    private maxConcurrentPages = 10; // Configurable max concurrent pages\n    private currentActivePages = 0;\n    private processing = false;\n    private readonly PAGE_IDLE_TIMEOUT = 60 * 1000; // 1 minute for idle pages\n    private readonly MAX_PAGE_LIFETIME = 5 * 60 * 1000; // 5 minutes max lifetime\n    private readonly CLEANUP_INTERVAL = 30 * 1000; // 30 seconds cleanup interval\n\n    __loadedPage: Page[] = [];\n\n    finalizerMap = new WeakMap<Page, ReturnType<typeof global.setTimeout>>();\n    snMap = new WeakMap<Page, number>();\n    livePages = new Set<Page>();\n    lastPageCreatedAt: number = 0;\n\n    circuitBreakerHosts: Set<string> = new Set();\n\n    // Map to store snapshot handlers for each page\n    snapshotHandlers = new WeakMap<Page, (snapshot: PageSnapshot) => void>();\n\n    constructor(\n    ) {\n        super();\n        this.setMaxListeners(2 * Math.floor(os.totalmem() / (256 * 1024 * 1024)) + 1);\n\n        this.on('crippled', () => {\n            this.__loadedPage.length = 0;\n            this.livePages.clear();\n            this.pagePool.forEach(mp => this.destroyManagedPage(mp));\n            this.pagePool.length = 0;\n            this.currentActivePages = 0;\n            // Reject all queued requests\n            this.requestQueue.forEach(req => req.reject(new ServiceCrashedError({ message: 'Browser crashed' })));\n            this.requestQueue.length = 0;\n        });\n``\n        // Start cleanup interval\n        this.__cleanupInterval = setInterval(() => this.cleanupIdlePages(), 30_000);\n\n        // Start emergency cleanup for test environments\n        if (process.env.NODE_ENV === 'test' || process.env.CI === 'true') {\n            this.__emergencyCleanupInterval = setInterval(() => this.emergencyCleanup(), 60_000);\n            this.__resourceMonitorInterval = setInterval(() => this.monitorResources(), 30_000);\n        }\n    }\n\n    /**\n     * Emergency cleanup for memory leak prevention\n     */\n    private emergencyCleanup(): void {\n        const now = Date.now();\n        const memUsage = process.memoryUsage();\n        const heapUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024);\n        const rssMB = Math.round(memUsage.rss / 1024 / 1024);\n\n        this.logger.info('Emergency cleanup check', {\n            heapUsedMB,\n            rssMB,\n            livePages: this.livePages.size,\n            poolPages: this.pagePool.length,\n            queueLength: this.requestQueue.length\n        });\n\n        // Force cleanup if memory usage is high\n        if (heapUsedMB > 512 || rssMB > 1024) {\n            this.logger.warn('High memory usage detected, forcing cleanup', {\n                heapUsedMB,\n                rssMB\n            });\n            \n            // Force cleanup all idle pages immediately\n            const idlePages = this.pagePool.filter(mp => !mp.inUse);\n            idlePages.forEach(mp => this.destroyManagedPage(mp));\n            \n            // If still high memory, force close oldest pages\n            if (this.pagePool.length > 5) {\n                const oldestPages = this.pagePool\n                    .sort((a, b) => a.createdAt - b.createdAt)\n                    .slice(0, Math.floor(this.pagePool.length / 2));\n                \n                oldestPages.forEach(mp => {\n                    this.logger.warn(`Force closing page ${mp.sn} due to high memory usage`);\n                    this.destroyManagedPage(mp);\n                });\n            }\n            \n            // Force garbage collection if available\n            if (global.gc) {\n                global.gc();\n                this.logger.info('Forced garbage collection');\n            }\n        }\n        \n        // Check for process lifetime\n        if (process.env.NODE_ENV === 'test' && (now - this.startTime) > this.maxLifetime) {\n            this.logger.warn('Test environment max lifetime exceeded, triggering restart');\n            this.emit('restart-needed');\n        }\n    }\n\n    /**\n     * Monitor resources and log warnings\n     */\n    private monitorResources(): void {\n        const memUsage = process.memoryUsage();\n        const heapUsedMB = Math.round(memUsage.heapUsed / 1024 / 1024);\n        const heapTotalMB = Math.round(memUsage.heapTotal / 1024 / 1024);\n        const rssMB = Math.round(memUsage.rss / 1024 / 1024);\n        const externalMB = Math.round(memUsage.external / 1024 / 1024);\n        \n        const stats = {\n            heap: {\n                used: heapUsedMB,\n                total: heapTotalMB,\n                percent: Math.round((heapUsedMB / heapTotalMB) * 100)\n            },\n            rss: rssMB,\n            external: externalMB,\n            pages: {\n                live: this.livePages.size,\n                pool: this.pagePool.length,\n                active: this.currentActivePages,\n                queue: this.requestQueue.length\n            },\n            uptime: Math.round(process.uptime())\n        };\n        \n        // Log detailed stats every 5 minutes or if there are issues\n        if (stats.heap.percent > 80 || stats.rss > 1024 || stats.pages.live > 20) {\n            this.logger.warn('Resource usage warning', stats);\n        } else {\n            this.logger.debug('Resource monitoring', stats);\n        }\n    }\n\n    briefPages() {\n    // eslint-disable-next-line max-len\n    this.logger.info(`Status: ${this.livePages.size} pages alive: ${Array.from(this.livePages).map((x) => this.snMap.get(x)).sort().join(', ')}; ${this.__loadedPage.length} idle pages: ${this.__loadedPage.map((x) => this.snMap.get(x)).sort().join(', ')}`);\n        this.logger.info(`Pool status: ${this.pagePool.length} total pages, ${this.currentActivePages} active, ${this.requestQueue.length} queued`);\n    }\n\n    private async createManagedPage(): Promise<ManagedPage> {\n        const sn = this._sn++;\n        let context: BrowserContext;\n        let page: Page;\n\n        if (!this.browser) {\n            throw new Error('Browser not initialized');\n        }\n\n        try {\n            context = this.browser.defaultBrowserContext();\n            page = await context.newPage();\n        } catch (error) {\n            this.logger.error(`Failed to create page ${sn}:`, { error: marshalErrorLike(error as Error) });\n            throw error;\n        }\n\n        const managedPage: ManagedPage = {\n            page,\n            context,\n            sn,\n            createdAt: Date.now(),\n            inUse: false,\n            lastUsed: Date.now()\n        };\n\n        this.snMap.set(page, sn);\n        this.logger.info(`Page ${sn} created.`);\n\n        await this.setupPage(page, sn);\n\n        return managedPage;\n    }\n\n    private async setupPage(page: Page, sn: number, options?: ScrappingOptions): Promise<void> {\n        const preparations: any[] = [];\n\n        preparations.push(page.setBypassCSP(true));\n\n        // Set viewport based on options or default\n        const viewport = {\n            width: options?.viewportWidth || 1024,\n            height: options?.viewportHeight || 1024\n        };\n        preparations.push(page.setViewport(viewport));\n\n        preparations.push(page.exposeFunction('reportSnapshot', (snapshot: PageSnapshot) => {\n            if (snapshot.href === 'about:blank') {\n                return;\n            }\n            const handler = this.snapshotHandlers.get(page);\n            if (handler) {\n                handler(snapshot);\n            }\n        }));\n        preparations.push(page.evaluateOnNewDocument(SCRIPT_TO_INJECT_INTO_FRAME));\n        preparations.push(page.setRequestInterception(true));\n\n        await Promise.all(preparations);\n        await page.goto('about:blank', { waitUntil: 'domcontentloaded' });\n\n        this.setupPageRequestHandling(page, sn);\n\n        this.livePages.add(page);\n        this.lastPageCreatedAt = Date.now();\n    }\n\n    private setupPageRequestHandling(page: Page, sn: number): void {\n        const domainSet = new Set<string>();\n        let reqCounter = 0;\n        let t0: number | undefined;\n        let halt = false;\n\n        page.on('request', (req: any) => {\n            reqCounter++;\n            if (halt) {\n                return req.abort('blockedbyclient', 1000);\n            }\n            t0 ??= Date.now();\n            const requestUrl = req.url();\n            if (!requestUrl.startsWith(\"http:\") && !requestUrl.startsWith(\"https:\") && requestUrl !== 'about:blank') {\n                return req.abort('blockedbyclient', 1000);\n            }\n\n            try {\n                const tldParsed = tldParse(requestUrl);\n                if (tldParsed.domain) domainSet.add(tldParsed.domain);\n            } catch (error) {\n                this.logger.warn(`Failed to parse TLD for URL: ${requestUrl}. Using fallback method.`);\n                const simpleDomain = this.extractDomain(requestUrl);\n                if (simpleDomain) domainSet.add(simpleDomain);\n            }\n\n            const parsedUrl = new URL(requestUrl);\n\n            if (this.circuitBreakerHosts.has(parsedUrl.hostname.toLowerCase())) {\n                page.emit('abuse', { url: requestUrl, page, sn, reason: `Abusive request: ${requestUrl}` });\n                return req.abort('blockedbyclient', 1000);\n            }\n\n            if (\n                parsedUrl.hostname === 'localhost' ||\n                parsedUrl.hostname.startsWith('127.')\n            ) {\n                page.emit('abuse', { url: requestUrl, page, sn, reason: `Suspicious action: Request to localhost: ${requestUrl}` });\n                return req.abort('blockedbyclient', 1000);\n            }\n\n            const dt = Math.ceil((Date.now() - t0) / 1000);\n            const rps = reqCounter / dt;\n\n            if (reqCounter > 1000) {\n                if (rps > 60 || reqCounter > 2000) {\n                    page.emit('abuse', { url: requestUrl, page, sn, reason: `DDoS attack suspected: Too many requests` });\n                    halt = true;\n                    return req.abort('blockedbyclient', 1000);\n                }\n            }\n\n            if (domainSet.size > 200) {\n                page.emit('abuse', { url: requestUrl, page, sn, reason: `DDoS attack suspected: Too many domains` });\n                halt = true;\n                return req.abort('blockedbyclient', 1000);\n            }\n\n            req.continue().catch(() => {/* Ignore errors on continue */});\n        });\n    }\n\n    private destroyManagedPage(managedPage: ManagedPage): Promise<void> {\n        return new Promise<void>((resolve) => {\n            const { page, sn } = managedPage;\n\n            if (this.finalizerMap.has(page)) {\n                clearTimeout(this.finalizerMap.get(page)!);\n                this.finalizerMap.delete(page);\n            }\n\n            this.logger.info(`Destroying managed page ${sn}`);\n            this.livePages.delete(page);\n            this.snMap.delete(page);\n\n            const index = this.pagePool.indexOf(managedPage);\n            if (index !== -1) {\n                this.pagePool.splice(index, 1);\n            }\n\n            if (managedPage.inUse) {\n                this.currentActivePages--;\n            }\n\n            if (page.isClosed()) {\n                resolve();\n                return;\n            }\n\n            Promise.race([\n                (async () => {\n                    try {\n                        const context = page.browserContext();\n                        await page.close();\n                        if (context.pages && (await context.pages()).length === 0) {\n                            await context.close();\n                        }\n                    } catch (error) {\n                        this.logger.warn(`Error closing page ${sn}:`, { error: marshalErrorLike(error as Error) });\n                    }\n                })(),\n                delay(5000)\n            ]).finally(() => {\n                resolve();\n            });\n        });\n    }\n\n    private cleanupIdlePages(): void {\n        const now = Date.now();\n        \n        // Clean up idle pages\n        const idlePages = this.pagePool.filter(mp =>\n            !mp.inUse && (now - mp.lastUsed) > this.PAGE_IDLE_TIMEOUT\n        );\n\n        // Clean up pages that have exceeded max lifetime\n        const expiredPages = this.pagePool.filter(mp =>\n            (now - mp.createdAt) > this.MAX_PAGE_LIFETIME\n        );\n\n        const pagesToCleanup = [...new Set([...idlePages, ...expiredPages])];\n        \n        if (pagesToCleanup.length > 0) {\n            this.logger.info(`Cleaning up ${pagesToCleanup.length} pages`, {\n                idle: idlePages.length,\n                expired: expiredPages.length\n            });\n            \n            pagesToCleanup.forEach(mp => {\n                this.logger.debug(`Cleaning up page ${mp.sn}`, {\n                    idle: !mp.inUse && (now - mp.lastUsed) > this.PAGE_IDLE_TIMEOUT,\n                    expired: (now - mp.createdAt) > this.MAX_PAGE_LIFETIME,\n                    inUse: mp.inUse\n                });\n                this.destroyManagedPage(mp);\n            });\n        }\n    }\n\n    private processQueue(): void {\n        if (this.processing || this.requestQueue.length === 0) {\n            return;\n        }\n        this.processing = true;\n\n        this.requestQueue.sort((a, b) => {\n            if (a.priority !== b.priority) return b.priority - a.priority;\n            return a.timestamp - b.timestamp;\n        });\n\n        while (this.requestQueue.length > 0 && this.currentActivePages < this.maxConcurrentPages) {\n            const request = this.requestQueue.shift()!;\n            let availablePage = this.pagePool.find(mp => !mp.inUse);\n\n            if (availablePage) {\n                availablePage.inUse = true;\n                availablePage.lastUsed = Date.now();\n                this.currentActivePages++;\n                request.resolve(availablePage.page);\n            } else if (this.pagePool.length < this.maxConcurrentPages) {\n                this.createManagedPage().then(managedPage => {\n                    this.pagePool.push(managedPage);\n                    managedPage.inUse = true;\n                    this.currentActivePages++;\n                    request.resolve(managedPage.page);\n                }).catch(error => {\n                    request.reject(error);\n                });\n            } else {\n                this.requestQueue.unshift(request);\n                break;\n            }\n        }\n        this.processing = false;\n    }\n\n    override async init() {\n        if (this.__healthCheckInterval) {\n            clearInterval(this.__healthCheckInterval);\n            this.__healthCheckInterval = undefined;\n        }\n        if (this.__cleanupInterval) {\n            clearInterval(this.__cleanupInterval);\n            this.__cleanupInterval = undefined;\n        }\n        await this.dependencyReady();\n\n        if (this.browser) {\n            if (this.browser.connected) {\n                await this.browser.close();\n            } else {\n                this.browser.process()?.kill('SIGKILL');\n            }\n        }\n        const args = [\n            '--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage',\n            '--disable-background-timer-throttling', '--disable-backgrounding-occluded-windows',\n            '--disable-renderer-backgrounding', '--disable-features=TranslateUI',\n            '--disable-ipc-flooding-protection', '--disable-web-security',\n            '--disable-features=VizDisplayCompositor', '--no-first-run', '--no-zygote',\n            '--disable-gpu', '--headless=new', '--disable-extensions',\n            '--disable-default-apps', '--disable-sync', '--no-default-browser-check',\n            '--disable-background-networking', '--disable-component-update'\n        ];\n\n        const execPath = process.env.PUPPETEER_EXECUTABLE_PATH || process.env.CHROMIUM_EXECUTABLE || undefined;\n        const launchOpts: any = {\n            args,\n            timeout: 10_000,\n            handleSIGINT: false,\n            handleSIGTERM: false,\n            handleSIGHUP: false,\n        };\n        if (execPath) launchOpts.executablePath = execPath;\n\n        this.browser = await puppeteer.launch(launchOpts).catch((err: any) => {\n            this.logger.error(`Browser launch failed.`, { err });\n            process.nextTick(() => this.emit('error', err));\n            return Promise.reject(err);\n        });\n        this.browser.once('disconnected', () => {\n            this.logger.warn(`Browser disconnected`);\n            this.emit('crippled');\n            process.nextTick(() => this.serviceReady());\n        });\n        this.logger.info(`Browser launched: ${this.browser.process()?.pid}`);\n        this.emit('ready');\n\n        this.__healthCheckInterval = setInterval(() => this.healthCheck(), 30_000);\n        this.newPage().then((r) => this.__loadedPage.push(r));\n    }\n\n    @maxConcurrency(1)\n    async healthCheck() {\n        if (Date.now() - this.lastPageCreatedAt <= 10_000) {\n            this.briefPages();\n            return;\n        }\n        const healthyPage = await this.newPage().catch((err) => {\n            this.logger.warn(`Health check failed`, { err: marshalErrorLike(err) });\n            return null;\n        });\n\n        if (healthyPage) {\n            this.__loadedPage.push(healthyPage);\n            if (this.__loadedPage.length > 3) {\n                this.ditchPage(this.__loadedPage.shift()!);\n            }\n            this.briefPages();\n            return;\n        }\n\n        this.logger.warn(`Trying to clean up...`);\n        this.browser.process()?.kill('SIGKILL');\n        Reflect.deleteProperty(this, 'browser');\n        this.emit('crippled');\n        this.logger.warn(`Browser killed`);\n    }\n\n    // FIX: Corrected the structure of this method. It was previously malformed.\n    private extractDomain(url: string): string | null {\n        try {\n            const { hostname } = new URL(url);\n            const parts = hostname.split('.');\n            return parts.length > 1 ? parts.slice(-2).join('.') : hostname;\n        } catch (error: any) {\n            this.logger.warn(`Failed to extract domain from URL: ${url}. Error: ${error.message}`);\n            return null; // Return null on failure\n        }\n    }\n\n    // FIX: This method was previously inside `extractDomain` due to a copy-paste error.\n    // It's now a proper class method, intended for creating pre-warmed/health-check pages.\n    async newPage() {\n        await this.serviceReady();\n        if (!this.browser) {\n            throw new Error('Browser not initialized');\n        }\n        const dedicatedContext = this.browser.defaultBrowserContext();\n        const sn = this._sn++;\n        const page = await dedicatedContext.newPage();\n        const preparations: any[] = [];\n\n        preparations.push(page.setBypassCSP(true));\n        preparations.push(page.setViewport({ width: 1024, height: 1024 }));\n        preparations.push(page.exposeFunction('reportSnapshot', (snapshot: PageSnapshot) => {\n            if (snapshot.href === 'about:blank') return;\n            const handler = this.snapshotHandlers.get(page);\n            if (handler) handler(snapshot);\n        }));\n        preparations.push(page.evaluateOnNewDocument(SCRIPT_TO_INJECT_INTO_FRAME));\n        preparations.push(page.setRequestInterception(true));\n\n        await Promise.all(preparations);\n        await page.goto('about:blank', { waitUntil: 'domcontentloaded' });\n\n        this.setupPageRequestHandling(page, sn);\n\n        this.snMap.set(page, sn);\n        this.logger.info(`Page ${sn} created (for pre-warming/health-check).`);\n        this.lastPageCreatedAt = Date.now();\n        this.livePages.add(page);\n\n        return page;\n    }\n\n    async getNextPage(priority: number = 0): Promise<Page> {\n        return new Promise<Page>((resolve, reject) => {\n            const request: QueuedRequest = { resolve, reject, priority, timestamp: Date.now() };\n            this.requestQueue.push(request);\n\n            const timeout = setTimeout(() => {\n                const index = this.requestQueue.indexOf(request);\n                if (index !== -1) {\n                    this.requestQueue.splice(index, 1);\n                    reject(new Error('Page request timeout'));\n                }\n            }, 30000);\n\n            request.resolve = (page: Page) => { clearTimeout(timeout); resolve(page); };\n            request.reject = (error: any) => { clearTimeout(timeout); reject(error); };\n\n            this.processQueue();\n        });\n    }\n\n    releasePage(page: Page): void {\n        const managedPage = this.pagePool.find(mp => mp.page === page);\n        if (managedPage && managedPage.inUse) {\n            managedPage.inUse = false;\n            managedPage.lastUsed = Date.now();\n            this.currentActivePages--;\n            this.processQueue();\n        }\n    }\n\n    async ditchPage(page: Page) {\n        if (this.finalizerMap.has(page)) {\n            clearTimeout(this.finalizerMap.get(page)!);\n            this.finalizerMap.delete(page);\n        }\n        if (page.isClosed()) return;\n\n        const sn = this.snMap.get(page);\n        this.logger.info(`Ditching page ${sn}`);\n        this.livePages.delete(page);\n        try {\n            await Promise.race([page.close(), delay(5000)]);\n        } catch (err) {\n            this.logger.error(`Failed to ditch page ${sn}`, { err: marshalErrorLike(err as Error) });\n        }\n    }\n\n    async *scrape(parsedUrl: URL, options: ScrappingOptions = {}): AsyncGenerator<PageSnapshot> {\n        const url = parsedUrl.toString();\n        let page: Page | null = null;\n\n        try {\n            page = await this.getNextPage(1); // Higher priority for scraping\n            const sn = this.snMap.get(page) ?? -1;\n            this.logger.info(`Page ${sn}: Scraping ${url}`);\n\n            // Configure viewport based on options\n            if (options.viewportWidth || options.viewportHeight) {\n                const viewport = {\n                    width: options.viewportWidth || 1024,\n                    height: options.viewportHeight || 1024\n                };\n                await page.setViewport(viewport);\n                this.logger.info(`Page ${sn}: Set viewport to ${viewport.width}x${viewport.height}`);\n            }\n\n            if (options.proxyUrl && (page as any).useProxy) {\n                await (page as any).useProxy(options.proxyUrl);\n            }\n\n            if (options.cookies) {\n                try {\n                    options.cookies.forEach(validateCookie);\n                    await page.setCookie(...options.cookies);\n                } catch (error) {\n                    this.logger.error(`Page ${sn}: Error setting cookies for ${url}`, { error, cookies: options.cookies });\n                    throw error;\n                }\n            }\n\n            if (options.overrideUserAgent) {\n                await page.setUserAgent(options.overrideUserAgent);\n            }\n\n            const nextSnapshotDeferred = Defer<PageSnapshot>();\n            const crippleListener = () => nextSnapshotDeferred.reject(new ServiceCrashedError({ message: `Browser crashed` }));\n            this.once('crippled', crippleListener);\n            nextSnapshotDeferred.promise.finally(() => this.off('crippled', crippleListener));\n\n            let lastSnapshot: PageSnapshot | undefined;\n            const hdl = (s: PageSnapshot) => {\n                if (s?.maxElemDepth && s.maxElemDepth > 256) return;\n                if (s?.elemCount && s.elemCount > 10_000) return;\n                lastSnapshot = s;\n                nextSnapshotDeferred.resolve(s);\n            };\n            this.snapshotHandlers.set(page, hdl);\n\n            const timeout = options.timeoutMs || 30_000;\n\n            const gotoPromise = page.goto(url, { waitUntil: 'load', timeout })\n                .catch(err => {\n                    if (err.name === 'TimeoutError' || err.message?.includes('ERR_NAME_NOT_RESOLVED')) {\n                        this.logger.warn(`Page ${sn}: Navigation to ${url} failed`, { err: marshalErrorLike(err) });\n                        return; // Don't re-throw, just let it proceed to snapshotting if possible\n                    }\n                    throw err; // Re-throw other errors\n                });\n\n            const waitForPromise = options.waitForSelector\n                ? page.waitForSelector(\n                    Array.isArray(options.waitForSelector) ? options.waitForSelector.join(', ') : options.waitForSelector,\n                    { timeout }\n                  ).catch(err => {\n                      this.logger.warn(`Page ${sn}: waitForSelector failed for ${url}`, { err: marshalErrorLike(err) });\n                  })\n                : Promise.resolve();\n\n            await Promise.all([gotoPromise, waitForPromise]);\n\n            // Wait for a snapshot to be reported\n            await Promise.race([nextSnapshotDeferred.promise, delay(options.minIntervalMs || 1000)]);\n\n            const finalSnapshot = lastSnapshot || await page.evaluate('giveSnapshot()').catch(() => null) as PageSnapshot | null;\n\n            if (finalSnapshot) {\n                this.logger.info(`Page ${sn}: Snapshot of ${url} done`, { title: finalSnapshot.title || 'Untitled' });\n                yield finalSnapshot;\n            } else {\n                this.logger.warn(`Page ${sn}: No snapshot available for ${url}, trying screenshot.`);\n                const screenshot = await page.screenshot().catch(() => undefined) as Buffer | undefined;\n                const title = await page.title().catch(() => 'Scraping Failed');\n                yield {\n                    title,\n                    href: url,\n                    html: '',\n                    text: '',\n                    screenshot,\n                    error: 'No snapshot available, screenshot taken as fallback.'\n                };\n            }\n\n        } catch (error: any) {\n            this.logger.error(`Scraping failed for ${url}:`, { error: marshalErrorLike(error) });\n            yield {\n                title: 'Error: Scraping failed',\n                href: url,\n                html: '',\n                text: '',\n                error: error.message || 'An unknown error occurred during scraping.'\n            };\n        } finally {\n            if (page) {\n                this.snapshotHandlers.delete(page);\n                if (options.proxyUrl && (page as any).useProxy) {\n                    await (page as any).useProxy(null); // Clear proxy\n                }\n                this.releasePage(page);\n            }\n        }\n    }\n\n    async salvage(url: string, page: Page) {\n        this.logger.info(`Salvaging ${url}`);\n        const googleArchiveUrl = `https://webcache.googleusercontent.com/search?q=cache:${encodeURIComponent(url)}`;\n        const resp = await fetch(googleArchiveUrl, {\n            headers: { 'User-Agent': `Mozilla/5.0 AppleWebKit/537.36 (KHTML, like Gecko; compatible; GPTBot/1.0; +https://openai.com/gptbot)` }\n        });\n        if (!resp.ok) {\n            this.logger.warn(`No salvation found for url: ${url}`, { status: resp.status });\n            return null;\n        }\n\n        await page.goto(googleArchiveUrl, { waitUntil: 'load', timeout: 15_000 }).catch((err: any) => {\n            this.logger.warn(`Page salvation did not fully succeed.`, { err: marshalErrorLike(err) });\n        });\n\n        this.logger.info(`Salvation completed.`);\n        return true;\n    }\n\n    async snapshotChildFrames(page: Page): Promise<PageSnapshot[]> {\n        const childFrames = page.mainFrame().childFrames();\n        const results = await Promise.all(childFrames.map(async (frame) => {\n            const frameUrl = frame.url();\n            if (!frameUrl || frameUrl === 'about:blank') return undefined;\n            try {\n                await frame.evaluate(SCRIPT_TO_INJECT_INTO_FRAME);\n                return await frame.evaluate(`giveSnapshot()`) as PageSnapshot;\n            } catch (err) {\n                this.logger.warn(`Failed to snapshot child frame ${frameUrl}`, { err });\n                return undefined;\n            }\n        }));\n        return results.filter((r): r is PageSnapshot => Boolean(r));\n    }\n\n    async crawl(url: URL, options?: ScrappingOptions): Promise<PageSnapshot | undefined> {\n        const iterator = this.scrape(url, options);\n        for await (const snapshot of iterator) {\n            if (snapshot) {\n                return snapshot;\n            }\n        }\n        return undefined;\n    }\n\n    async close() {\n        // Mark as closing to prevent new operations\n        this.isClosing = true;\n\n        // Clear intervals\n        if (this.__healthCheckInterval) {\n            clearInterval(this.__healthCheckInterval);\n            this.__healthCheckInterval = undefined;\n        }\n        if (this.__cleanupInterval) {\n            clearInterval(this.__cleanupInterval);\n            this.__cleanupInterval = undefined;\n        }\n        if (this.__emergencyCleanupInterval) {\n            clearInterval(this.__emergencyCleanupInterval);\n            this.__emergencyCleanupInterval = undefined;\n        }\n        if (this.__resourceMonitorInterval) {\n            clearInterval(this.__resourceMonitorInterval);\n            this.__resourceMonitorInterval = undefined;\n        }\n\n        // Reject all pending requests to clear their timeouts\n        this.requestQueue.forEach(req => {\n            try {\n                req.reject(new Error('PuppeteerControl is closing'));\n            } catch (e) {\n                // Ignore errors from already resolved requests\n            }\n        });\n        this.requestQueue.length = 0;\n\n        // Clean up all page finalizers by going through all pages we know about\n        for (const page of this.livePages) {\n            if (this.finalizerMap.has(page)) {\n                const timeout = this.finalizerMap.get(page);\n                if (timeout) {\n                    clearTimeout(timeout);\n                }\n                this.finalizerMap.delete(page);\n            }\n        }\n\n        // Close all pages in the pool\n        for (const managedPage of this.pagePool) {\n            try {\n                if (!managedPage.page.isClosed()) {\n                    await managedPage.page.close();\n                }\n            } catch (e) {\n                // Ignore errors from already closed pages\n            }\n        }\n        this.pagePool.length = 0;\n\n        // Close loaded pages\n        for (const page of this.__loadedPage) {\n            try {\n                if (!page.isClosed()) {\n                    await page.close();\n                }\n            } catch (e) {\n                // Ignore errors from already closed pages\n            }\n        }\n        this.__loadedPage.length = 0;\n\n        // Close browser\n        if (this.browser && this.browser.connected) {\n            await this.browser.close();\n        }\n\n        // Clear sets (WeakMaps will be garbage collected when pages are destroyed)\n        this.livePages.clear();\n        this.circuitBreakerHosts.clear();\n\n        // Mark as closing to prevent new operations\n        this.isClosing = true;\n    }\n\n}\n\nconst puppeteerControl = container.resolve(PuppeteerControl);\n\nexport default puppeteerControl;\n"],
  "mappings": "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",
  "names": []
}
