{
  "version": 3,
  "sources": ["../../../src/services/cache.ts"],
  "sourcesContent": ["import NodeCache from 'node-cache';\nimport { singleton } from 'tsyringe';\nimport { Logger } from '../shared/logger.js';\nimport { config } from '../shared/config-manager.js';\nimport { createHash } from 'crypto';\n\nexport interface CacheEntry<T = any> {\n  data: T;\n  timestamp: number;\n  ttl: number;\n}\n\n@singleton()\nexport class ResponseCacheService {\n  private cache: NodeCache;\n  private logger = new Logger('ResponseCache');\n\n  constructor() {\n    this.cache = new NodeCache({\n      stdTTL: 600, // 10 minutes default TTL\n      maxKeys: config.cache.cache_size_limit,\n      checkperiod: 120, // Check for expired keys every 2 minutes\n      useClones: false // Better performance, but be careful with mutations\n    });\n\n    this.cache.on('set', (key, value) => {\n      this.logger.debug('Cache entry set', { key, size: JSON.stringify(value).length });\n    });\n\n    this.cache.on('expired', (key) => {\n      this.logger.debug('Cache entry expired', { key });\n    });\n\n    this.cache.on('del', (key) => {\n      this.logger.debug('Cache entry deleted', { key });\n    });\n  }\n\n  /**\n   * Generate a cache key from URL and options\n   */\n  private generateKey(url: string, options?: Record<string, any>): string {\n    const keyData = {\n      url: url.toLowerCase().trim(),\n      ...options\n    };\n    \n    const keyString = JSON.stringify(keyData, Object.keys(keyData).sort());\n    return createHash('md5').update(keyString).digest('hex');\n  }\n\n  /**\n   * Get cached response\n   */\n  get<T = any>(url: string, options?: Record<string, any>): T | null {\n    if (!config.cache.enable_response_cache) {\n      return null;\n    }\n\n    const key = this.generateKey(url, options);\n    const cached = this.cache.get<CacheEntry<T>>(key);\n    \n    if (cached) {\n      this.logger.debug('Cache hit', { key, url });\n      return cached.data;\n    }\n    \n    this.logger.debug('Cache miss', { key, url });\n    return null;\n  }\n\n  /**\n   * Set cached response\n   */\n  set<T = any>(url: string, data: T, ttlSeconds?: number, options?: Record<string, any>): boolean {\n    if (!config.cache.enable_response_cache) {\n      return false;\n    }\n\n    const key = this.generateKey(url, options);\n    const ttl = ttlSeconds || 600; // 10 minutes default\n    \n    const entry: CacheEntry<T> = {\n      data,\n      timestamp: Date.now(),\n      ttl\n    };\n\n    const success = this.cache.set(key, entry, ttl);\n    \n    if (success) {\n      this.logger.debug('Cache entry stored', { \n        key, \n        url, \n        ttl, \n        size: JSON.stringify(data).length \n      });\n    } else {\n      this.logger.warn('Failed to store cache entry', { key, url });\n    }\n    \n    return success;\n  }\n\n  /**\n   * Delete cached response\n   */\n  delete(url: string, options?: Record<string, any>): boolean {\n    const key = this.generateKey(url, options);\n    const deleted = this.cache.del(key);\n    \n    if (deleted > 0) {\n      this.logger.debug('Cache entry deleted', { key, url });\n    }\n    \n    return deleted > 0;\n  }\n\n  /**\n   * Clear all cached responses\n   */\n  clear(): void {\n    this.cache.flushAll();\n    this.logger.info('All cache entries cleared');\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getStats() {\n    const stats = this.cache.getStats();\n    return {\n      keys: stats.keys,\n      hits: stats.hits,\n      misses: stats.misses,\n      ksize: stats.ksize,\n      vsize: stats.vsize,\n      hitRate: stats.hits / (stats.hits + stats.misses) || 0,\n      enabled: config.cache.enable_response_cache\n    };\n  }\n\n  /**\n   * Check if caching is enabled\n   */\n  isEnabled(): boolean {\n    return config.cache.enable_response_cache;\n  }\n\n  /**\n   * Cache content extraction results\n   */\n  cacheContentExtraction(url: string, content: any, options?: { \n    format?: string;\n    userAgent?: string;\n    cookies?: boolean;\n  }): boolean {\n    if (!options?.cookies) { // Don't cache if cookies were used (privacy)\n      const ttl = this.determineTTL(content);\n      return this.set(url, content, ttl, options);\n    }\n    return false;\n  }\n\n  /**\n   * Get cached content extraction\n   */\n  getCachedContentExtraction(url: string, options?: {\n    format?: string;\n    userAgent?: string;\n  }): any {\n    return this.get(url, options);\n  }\n\n  /**\n   * Determine appropriate TTL based on content type and freshness\n   */\n  private determineTTL(content: any): number {\n    // Base TTL of 10 minutes\n    let ttl = 600;\n\n    // If content has a published date, cache longer for older content\n    if (content.publishedTime) {\n      const publishedDate = new Date(content.publishedTime);\n      const ageInDays = (Date.now() - publishedDate.getTime()) / (1000 * 60 * 60 * 24);\n      \n      if (ageInDays > 365) {\n        ttl = 3600; // 1 hour for content older than a year\n      } else if (ageInDays > 30) {\n        ttl = 1800; // 30 minutes for content older than a month\n      }\n    }\n\n    // Shorter TTL for dynamic content indicators\n    if (content.title?.toLowerCase().includes('live') || \n        content.title?.toLowerCase().includes('breaking') ||\n        content.content?.toLowerCase().includes('updated')) {\n      ttl = 300; // 5 minutes for live/breaking content\n    }\n\n    return ttl;\n  }\n\n  /**\n   * Warm cache with common URLs\n   */\n  async warmCache(urls: string[]): Promise<void> {\n    this.logger.info(`Warming cache with ${urls.length} URLs`);\n    \n    for (const url of urls) {\n      if (!this.get(url)) {\n        // This would typically trigger a background fetch\n        // For now, just log the URLs that would be warmed\n        this.logger.debug('URL not in cache, would warm', { url });\n      }\n    }\n  }\n\n  /**\n   * Cleanup expired entries (called periodically)\n   */\n  cleanup(): void {\n    const beforeKeys = this.cache.keys().length;\n    // Force check for expired keys\n    this.cache.keys().forEach(key => this.cache.get(key));\n    const afterKeys = this.cache.keys().length;\n    \n    if (beforeKeys !== afterKeys) {\n      this.logger.info('Cache cleanup completed', { \n        removedEntries: beforeKeys - afterKeys,\n        remainingEntries: afterKeys\n      });\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
