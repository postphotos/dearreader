{
  "version": 3,
  "sources": ["../../../../src/services/__tests__/pdf-ocr.test.ts"],
  "sourcesContent": ["import { expect } from 'chai';\nimport PDFExtractor from '../pdf-extract.js';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\ndescribe('PDF OCR Integration', () => {\n    // Check if OCR is available\n    const ocrAvailable = process.env.TESSERACT_AVAILABLE === 'true';\n\n    describe('OCR Text Extraction', function() {\n        it('should handle OCR availability check', () => {\n            // This test always passes - it verifies the OCR availability logic\n            if (ocrAvailable) {\n                console.log('\u2705 Tesseract OCR is available');\n            } else {\n                console.log('\u26A0\uFE0F  Tesseract OCR not available - OCR tests will be limited');\n            }\n            expect(typeof ocrAvailable).to.equal('boolean');\n        });\n\n        if (ocrAvailable) {\n            it('should extract text from image-based PDF using OCR', async function() {\n                this.timeout(60000); // OCR can take time\n\n                // Create a simple test image buffer\n                // In a real scenario, this would be a scanned PDF page\n                const imageBuffer = Buffer.from('fake-image-data-for-testing');\n\n                try {\n                    const result = await PDFExtractor.extractTextWithOCR(imageBuffer);\n                    expect(result).to.be.a('string');\n                    // OCR might return empty string for fake data, which is acceptable\n                } catch (error: any) {\n                    // OCR errors are expected for fake image data\n                    expect(error).to.be.an('error');\n                }\n            });\n\n            it('should handle OCR with different image formats', async function() {\n                this.timeout(60000);\n\n                // Test with different buffer types\n                const testBuffers = [\n                    Buffer.from(''),\n                    Buffer.from('minimal-data'),\n                    Buffer.alloc(100) // 100 bytes of zeros\n                ];\n\n                for (const buffer of testBuffers) {\n                    try {\n                        const result = await PDFExtractor.extractTextWithOCR(buffer);\n                        expect(result).to.be.a('string');\n                    } catch (error: any) {\n                        // Expected for invalid image data\n                        expect(error).to.be.an('error');\n                    }\n                }\n            });\n        } else {\n            it('should gracefully handle missing OCR when Tesseract is unavailable', () => {\n                // When OCR is not available, the system should still function\n                // This test verifies that the OCR availability check works correctly\n                expect(ocrAvailable).to.equal(false);\n            });\n        }\n    });\n\n    describe('PDF Processing with OCR Fallback', () => {\n        it('should attempt OCR when PDF has minimal text content', async () => {\n            // Create a PDF with very little text content\n            const minimalTextPdf = Buffer.from(\n                '%PDF-1.4\\n' +\n                '1 0 obj\\n' +\n                '<<\\n' +\n                '/Type /Catalog\\n' +\n                '/Pages 2 0 R\\n' +\n                '>>\\n' +\n                'endobj\\n' +\n                '2 0 obj\\n' +\n                '<<\\n' +\n                '/Type /Pages\\n' +\n                '/Kids [3 0 R]\\n' +\n                '/Count 1\\n' +\n                '>>\\n' +\n                'endobj\\n' +\n                '3 0 obj\\n' +\n                '<<\\n' +\n                '/Type /Page\\n' +\n                '/Parent 2 0 R\\n' +\n                '/MediaBox [0 0 612 792]\\n' +\n                '/Contents 4 0 R\\n' +\n                '>>\\n' +\n                'endobj\\n' +\n                '4 0 obj\\n' +\n                '<<\\n' +\n                '/Length 12\\n' +\n                '>>\\n' +\n                'stream\\n' +\n                'BT\\n' +\n                'ET\\n' + // Empty text content\n                'endstream\\n' +\n                'endobj\\n' +\n                'xref\\n' +\n                '0 5\\n' +\n                '0000000000 65535 f\\n' +\n                '0000000009 00000 n\\n' +\n                '0000000058 00000 n\\n' +\n                '0000000115 00000 n\\n' +\n                '0000000177 00000 n\\n' +\n                'trailer\\n' +\n                '<<\\n' +\n                '/Size 5\\n' +\n                '/Root 1 0 R\\n' +\n                '>>\\n' +\n                'startxref\\n' +\n                '261\\n' +\n                '%%EOF',\n                'utf8'\n            );\n\n            const result = await PDFExtractor.extractTextFromPDF(minimalTextPdf);\n            expect(result).to.be.a('string');\n            // Should return minimal or empty text\n        });\n\n        it('should prefer native PDF text over OCR when available', async () => {\n            // Create a PDF with substantial text content\n            const textPdf = Buffer.from(\n                '%PDF-1.4\\n' +\n                '1 0 obj\\n' +\n                '<<\\n' +\n                '/Type /Catalog\\n' +\n                '/Pages 2 0 R\\n' +\n                '>>\\n' +\n                'endobj\\n' +\n                '2 0 obj\\n' +\n                '<<\\n' +\n                '/Type /Pages\\n' +\n                '/Kids [3 0 R]\\n' +\n                '/Count 1\\n' +\n                '>>\\n' +\n                'endobj\\n' +\n                '3 0 obj\\n' +\n                '<<\\n' +\n                '/Type /Page\\n' +\n                '/Parent 2 0 R\\n' +\n                '/MediaBox [0 0 612 792]\\n' +\n                '/Contents 4 0 R\\n' +\n                '>>\\n' +\n                'endobj\\n' +\n                '4 0 obj\\n' +\n                '<<\\n' +\n                '/Length 68\\n' +\n                '>>\\n' +\n                'stream\\n' +\n                'BT\\n' +\n                '72 720 Td\\n' +\n                '/F0 12 Tf\\n' +\n                '(This is substantial text content for testing.) Tj\\n' +\n                'ET\\n' +\n                'endstream\\n' +\n                'endobj\\n' +\n                'xref\\n' +\n                '0 5\\n' +\n                '0000000000 65535 f\\n' +\n                '0000000009 00000 n\\n' +\n                '0000000058 00000 n\\n' +\n                '0000000115 00000 n\\n' +\n                '0000000200 00000 n\\n' +\n                'trailer\\n' +\n                '<<\\n' +\n                '/Size 5\\n' +\n                '/Root 1 0 R\\n' +\n                '>>\\n' +\n                'startxref\\n' +\n                '284\\n' +\n                '%%EOF',\n                'utf8'\n            );\n\n            const result = await PDFExtractor.extractTextFromPDF(textPdf);\n            expect(result).to.be.a('string');\n            expect(result.length).to.be.greaterThan(10);\n            expect(result).to.include('substantial text content');\n        });\n    });\n\n    describe('OCR Configuration', () => {\n        it('should respect OCR enable/disable configuration', async () => {\n            // Test that OCR is attempted when enabled\n            const minimalTextPdf = Buffer.from(\n                '%PDF-1.4\\n' +\n                '1 0 obj\\n' +\n                '<<\\n' +\n                '/Type /Catalog\\n' +\n                '/Pages 2 0 R\\n' +\n                '>>\\n' +\n                'endobj\\n' +\n                '2 0 obj\\n' +\n                '<<\\n' +\n                '/Type /Pages\\n' +\n                '/Kids [3 0 R]\\n' +\n                '/Count 1\\n' +\n                '>>\\n' +\n                'endobj\\n' +\n                '3 0 obj\\n' +\n                '<<\\n' +\n                '/Type /Page\\n' +\n                '/Parent 2 0 R\\n' +\n                '/MediaBox [0 0 612 792]\\n' +\n                '/Contents 4 0 R\\n' +\n                '>>\\n' +\n                'endobj\\n' +\n                '4 0 obj\\n' +\n                '<<\\n' +\n                '/Length 12\\n' +\n                '>>\\n' +\n                'stream\\n' +\n                'BT\\n' +\n                'ET\\n' +\n                'endstream\\n' +\n                'endobj\\n' +\n                'xref\\n' +\n                '0 5\\n' +\n                '0000000000 65535 f\\n' +\n                '0000000009 00000 n\\n' +\n                '0000000058 00000 n\\n' +\n                '0000000115 00000 n\\n' +\n                '0000000177 00000 n\\n' +\n                'trailer\\n' +\n                '<<\\n' +\n                '/Size 5\\n' +\n                '/Root 1 0 R\\n' +\n                '>>\\n' +\n                'startxref\\n' +\n                '261\\n' +\n                '%%EOF',\n                'utf8'\n            );\n\n            // This test verifies the method exists and can be called\n            // In a real scenario with OCR enabled, it would attempt OCR\n            const result = await PDFExtractor.extractTextFromPDF(minimalTextPdf);\n            expect(result).to.be.a('string');\n        });\n    });\n\n    describe('Performance and Error Handling', () => {\n        it('should handle large PDF files gracefully', async function() {\n            this.timeout(120000); // Allow more time for large files\n\n            // Create a larger PDF buffer\n            const largePdfContent = '%PDF-1.4\\n' + '0'.repeat(10000) + '\\n%%EOF';\n            const largeBuffer = Buffer.from(largePdfContent);\n\n            try {\n                const result = await PDFExtractor.extractTextFromPDF(largeBuffer);\n                expect(result).to.be.a('string');\n            } catch (error: any) {\n                // Large invalid PDFs should fail gracefully\n                expect(error).to.be.an('error');\n            }\n        });\n\n        it('should handle concurrent PDF processing', async function() {\n            this.timeout(60000);\n\n            const pdfBuffer = Buffer.from(\n                '%PDF-1.4\\n' +\n                '1 0 obj\\n<<\\n/Type /Catalog\\n/Pages 2 0 R\\n>>\\nendobj\\n' +\n                '2 0 obj\\n<<\\n/Type /Pages\\n/Kids [3 0 R]\\n/Count 1\\n>>\\nendobj\\n' +\n                '3 0 obj\\n<<\\n/Type /Page\\n/Parent 2 0 R\\n/MediaBox [0 0 612 792]\\n/Contents 4 0 R\\n>>\\nendobj\\n' +\n                '4 0 obj\\n<<\\n/Length 44\\n>>\\nstream\\nBT\\n72 720 Td\\n/F0 12 Tf\\n(Hello World!) Tj\\nET\\nendstream\\nendobj\\n' +\n                'xref\\n0 5\\n0000000000 65535 f\\n0000000009 00000 n\\n0000000058 00000 n\\n0000000115 00000 n\\n0000000200 00000 n\\n' +\n                'trailer\\n<<\\n/Size 5\\n/Root 1 0 R\\n>>\\nstartxref\\n284\\n%%EOF'\n            );\n\n            // Process multiple PDFs concurrently\n            const promises = Array(3).fill(null).map(() =>\n                PDFExtractor.extractTextFromPDF(pdfBuffer)\n            );\n\n            const results = await Promise.all(promises);\n\n            results.forEach(result => {\n                expect(result).to.be.a('string');\n                expect(result).to.include('Hello World');\n            });\n        });\n    });\n});"],
  "mappings": "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",
  "names": []
}
