{
  "version": 3,
  "sources": ["../../../src/services/rate-limit.ts"],
  "sourcesContent": ["import fs from 'fs';\nimport path from 'path';\nimport { singleton } from 'tsyringe';\nimport { Logger } from '../shared/logger.js';\nimport * as yaml from 'js-yaml';\n\nexport interface RateLimitConfig {\n  rpm_limit: number;\n  rpd_limit: number;\n}\n\nexport interface UsageRecord {\n  api_key: string;\n  provider: string;\n  timestamp: number;\n  requests_today: number;\n  requests_this_minute: number;\n  last_request_time: number;\n  // Sliding window data\n  request_timestamps: number[]; // Timestamps of recent requests\n}\n\nexport interface RateLimitResult {\n  allowed: boolean;\n  reason?: string;\n  usage?: UsageRecord;\n  headers?: {\n    'X-RateLimit-Limit': string;\n    'X-RateLimit-Remaining': string;\n    'X-RateLimit-Reset': string;\n    'X-RateLimit-Window'?: string;\n  };\n}\n\n@singleton()\nexport class RateLimitService {\n  private usageRecords: Map<string, UsageRecord> = new Map();\n  private logPath: string;\n  private logger: Logger;\n  private rateLimitConfig: any;\n  private slidingWindowSize: number = 60 * 1000; // 1 minute sliding window\n\n  constructor() {\n    this.logger = new Logger('RateLimit');\n    this.loadRateLimitConfig();\n    this.logPath = path.resolve(this.rateLimitConfig?.usage_log_path || './logs/api_usage.log');\n\n    // Ensure log directory exists\n    const logDir = path.dirname(this.logPath);\n    if (!fs.existsSync(logDir)) {\n      fs.mkdirSync(logDir, { recursive: true });\n    }\n\n    // Load existing usage records\n    this.loadUsageRecords();\n\n    // Set up daily reset\n    this.scheduleDailyReset();\n\n    // Set up periodic cleanup\n    this.scheduleCleanup();\n  }\n\n  private loadRateLimitConfig(): void {\n    try {\n      const configPath = path.resolve(__dirname, '..', '..', '..', 'crawl_pipeline.yaml');\n      if (fs.existsSync(configPath)) {\n        const configContent = fs.readFileSync(configPath, 'utf8');\n        const fullConfig = yaml.load(configContent) as any;\n        this.rateLimitConfig = fullConfig.rate_limiting;\n        this.logger.info('Rate limiting configuration loaded from crawl_pipeline.yaml');\n      } else {\n        this.logger.warn('crawl_pipeline.yaml not found, using default rate limiting config');\n        this.rateLimitConfig = {\n          enabled: false,\n          usage_log_path: './logs/api_usage.log',\n          daily_reset_hour: 0,\n          warning_threshold: 80,\n          providers: {}\n        };\n      }\n    } catch (error) {\n      this.logger.error('Failed to load rate limiting config:', error);\n      this.rateLimitConfig = { enabled: false, providers: {} };\n    }\n  }\n\n  /**\n   * Check if a request is allowed for the given API key and provider\n   */\n  async checkRateLimit(apiKey: string, provider: string): Promise<RateLimitResult> {\n    const key = `${apiKey}:${provider}`;\n    const now = Date.now();\n    const today = new Date().toDateString();\n    const thisMinute = Math.floor(now / 60000); // 60 second windows\n\n    // Get or create usage record\n    let record = this.usageRecords.get(key);\n    if (!record) {\n      record = {\n        api_key: apiKey,\n        provider,\n        timestamp: now,\n        requests_today: 0,\n        requests_this_minute: 0,\n        last_request_time: now,\n        request_timestamps: []\n      };\n      this.usageRecords.set(key, record);\n    }\n\n    // Reset counters if it's a new day\n    if (new Date(record.timestamp).toDateString() !== today) {\n      record.requests_today = 0;\n      record.timestamp = now;\n    }\n\n    // Reset minute counter if it's a new minute\n    if (Math.floor(record.last_request_time / 60000) !== thisMinute) {\n      record.requests_this_minute = 0;\n    }\n\n    // Get provider limits\n    const limits = this.getProviderLimits(provider);\n    if (!limits) {\n      return { allowed: true, usage: record }; // No limits defined, allow\n    }\n\n    // Check limits\n    if (record.requests_today >= limits.rpd_limit) {\n      const reason = `Daily limit exceeded: ${record.requests_today}/${limits.rpd_limit} requests`;\n      this.logger.warn(`Rate limit exceeded for ${key}: ${reason}`);\n      return {\n        allowed: false,\n        reason,\n        usage: record,\n        headers: this.generateRateLimitHeaders(record, limits, provider)\n      };\n    }\n\n    if (record.requests_this_minute >= limits.rpm_limit) {\n      const reason = `Minute limit exceeded: ${record.requests_this_minute}/${limits.rpm_limit} requests`;\n      this.logger.warn(`Rate limit exceeded for ${key}: ${reason}`);\n      return {\n        allowed: false,\n        reason,\n        usage: record,\n        headers: this.generateRateLimitHeaders(record, limits, provider)\n      };\n    }\n\n    // Check warning threshold\n    const warningThreshold = this.rateLimitConfig?.warning_threshold || 80;\n    const dailyUsagePercent = (record.requests_today / limits.rpd_limit) * 100;\n    const minuteUsagePercent = (record.requests_this_minute / limits.rpm_limit) * 100;\n\n    if (dailyUsagePercent >= warningThreshold) {\n      this.logger.warn(`High daily usage for ${key}: ${record.requests_today}/${limits.rpd_limit} (${dailyUsagePercent.toFixed(1)}%)`);\n    }\n\n    if (minuteUsagePercent >= warningThreshold) {\n      this.logger.warn(`High minute usage for ${key}: ${record.requests_this_minute}/${limits.rpm_limit} (${minuteUsagePercent.toFixed(1)}%)`);\n    }\n\n    return {\n      allowed: true,\n      usage: record,\n      headers: this.generateRateLimitHeaders(record, limits, provider)\n    };\n  }\n\n  /**\n   * Record a successful request\n   */\n  async recordRequest(apiKey: string, provider: string): Promise<void> {\n    const key = `${apiKey}:${provider}`;\n    const now = Date.now();\n    const thisMinute = Math.floor(now / 60000);\n\n    let record = this.usageRecords.get(key);\n    if (!record) {\n      record = {\n        api_key: apiKey,\n        provider,\n        timestamp: now,\n        requests_today: 0,\n        requests_this_minute: 0,\n        last_request_time: now,\n        request_timestamps: []\n      };\n    }\n\n    // Update counters\n    record.requests_today++;\n    record.requests_this_minute++;\n    record.last_request_time = now;\n\n    // Add timestamp for sliding window\n    record.request_timestamps.push(now);\n\n    // Keep only timestamps within the sliding window\n    const windowStart = now - this.slidingWindowSize;\n    record.request_timestamps = record.request_timestamps.filter(ts => ts > windowStart);\n\n    this.usageRecords.set(key, record);\n\n    // Save to log file\n    await this.saveUsageRecord(record);\n  }\n\n  /**\n   * Get usage statistics for an API key\n   */\n  getUsageStats(apiKey: string, provider?: string): { [key: string]: UsageRecord } {\n    const stats: { [key: string]: UsageRecord } = {};\n\n    for (const [key, record] of this.usageRecords.entries()) {\n      if (record.api_key === apiKey && (!provider || key.endsWith(`:${provider}`))) {\n        stats[key] = { ...record };\n      }\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get provider-specific rate limits\n   */\n  private getProviderLimits(provider: string): RateLimitConfig | null {\n    const providers = this.rateLimitConfig?.providers;\n    if (!providers || !providers[provider]) {\n      return null;\n    }\n\n    return {\n      rpm_limit: providers[provider].rpm_limit,\n      rpd_limit: providers[provider].rpd_limit\n    };\n  }\n\n  /**\n   * Load usage records from log file\n   */\n  private loadUsageRecords(): void {\n    try {\n      if (fs.existsSync(this.logPath)) {\n        const data = fs.readFileSync(this.logPath, 'utf8');\n        const lines = data.trim().split('\\n');\n\n        for (const line of lines) {\n          if (line.trim()) {\n            try {\n              const record: UsageRecord = JSON.parse(line);\n              const key = `${record.api_key}:${record.provider}`;\n\n              // Only load records from today\n              const today = new Date().toDateString();\n              if (new Date(record.timestamp).toDateString() === today) {\n                this.usageRecords.set(key, record);\n              }\n            } catch (e) {\n              this.logger.warn(`Failed to parse usage record: ${line}`);\n            }\n          }\n        }\n\n        this.logger.info(`Loaded ${this.usageRecords.size} usage records from ${this.logPath}`);\n      }\n    } catch (error) {\n      this.logger.error(`Failed to load usage records: ${error}`);\n    }\n  }\n\n  /**\n   * Save usage record to log file\n   */\n  private async saveUsageRecord(record: UsageRecord): Promise<void> {\n    try {\n      const logEntry = JSON.stringify(record) + '\\n';\n      fs.appendFileSync(this.logPath, logEntry);\n    } catch (error) {\n      this.logger.error(`Failed to save usage record: ${error}`);\n    }\n  }\n\n  /**\n   * Schedule daily reset of usage counters\n   */\n  private scheduleDailyReset(): void {\n    const resetHour = this.rateLimitConfig?.daily_reset_hour || 0;\n\n    const scheduleReset = () => {\n      const now = new Date();\n      const resetTime = new Date(now);\n      resetTime.setHours(resetHour, 0, 0, 0);\n\n      // If reset time has passed today, schedule for tomorrow\n      if (now >= resetTime) {\n        resetTime.setDate(resetTime.getDate() + 1);\n      }\n\n      const timeUntilReset = resetTime.getTime() - now.getTime();\n\n      setTimeout(() => {\n        this.resetDailyCounters();\n        // Schedule next reset\n        setTimeout(scheduleReset, 24 * 60 * 60 * 1000); // 24 hours\n      }, timeUntilReset);\n    };\n\n    scheduleReset();\n  }\n\n  /**\n   * Reset daily usage counters\n   */\n  private resetDailyCounters(): void {\n    const today = new Date().toDateString();\n\n    for (const [key, record] of this.usageRecords.entries()) {\n      // Reset if record is from yesterday\n      if (new Date(record.timestamp).toDateString() !== today) {\n        record.requests_today = 0;\n        record.timestamp = Date.now();\n        this.usageRecords.set(key, record);\n      }\n    }\n\n    this.logger.info('Daily usage counters reset');\n  }\n\n  /**\n   * Generate rate limit headers for response\n   */\n  private generateRateLimitHeaders(record: UsageRecord, limits: RateLimitConfig, provider: string): RateLimitResult['headers'] {\n    const now = Date.now();\n    const resetTime = new Date();\n    resetTime.setHours(23, 59, 59, 999); // End of today\n    const resetTimestamp = Math.floor(resetTime.getTime() / 1000);\n\n    // Calculate remaining requests\n    const remainingDaily = Math.max(0, limits.rpd_limit - record.requests_today);\n    const remainingMinute = Math.max(0, limits.rpm_limit - record.requests_this_minute);\n\n    return {\n      'X-RateLimit-Limit': `${limits.rpm_limit}`,\n      'X-RateLimit-Remaining': `${Math.min(remainingDaily, remainingMinute)}`,\n      'X-RateLimit-Reset': `${resetTimestamp}`,\n      'X-RateLimit-Window': '60' // 60 second window\n    };\n  }\n\n  /**\n   * Schedule periodic cleanup of old records\n   */\n  private scheduleCleanup(): void {\n    setInterval(() => {\n      this.cleanupOldRecords();\n    }, 60 * 60 * 1000); // Run cleanup every hour\n  }\n\n  /**\n   * Clean up old records (keep only last 30 days)\n   */\n  cleanupOldRecords(): void {\n    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\n    let removed = 0;\n\n    for (const [key, record] of this.usageRecords.entries()) {\n      if (record.timestamp < thirtyDaysAgo) {\n        this.usageRecords.delete(key);\n        removed++;\n      }\n    }\n\n    if (removed > 0) {\n      this.logger.info(`Cleaned up ${removed} old usage records`);\n    }\n  }\n}"],
  "mappings": "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",
  "names": []
}
