{
  "version": 3,
  "sources": ["../../../src/shared/error-handler.ts"],
  "sourcesContent": ["import { Logger } from './logger.js';\nimport { Request, Response } from 'express';\n\nexport interface ErrorContext {\n  request?: Request;\n  url?: string;\n  userId?: string;\n  operation?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface ErrorResponse {\n  error: string;\n  message: string;\n  code: number;\n  timestamp: string;\n  requestId?: string;\n  details?: any;\n}\n\nexport class ApplicationError extends Error {\n  public readonly code: number;\n  public readonly statusCode: number;\n  public readonly isOperational: boolean;\n  public readonly context?: ErrorContext;\n\n  constructor(\n    message: string,\n    code: number = 500,\n    statusCode: number = 500,\n    isOperational: boolean = true,\n    context?: ErrorContext\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.statusCode = statusCode;\n    this.isOperational = isOperational;\n    this.context = context;\n\n    // Ensure the stack trace starts from the caller\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nexport class ValidationError extends ApplicationError {\n  constructor(message: string, context?: ErrorContext) {\n    super(message, 400, 400, true, context);\n  }\n}\n\nexport class NotFoundError extends ApplicationError {\n  constructor(resource: string, context?: ErrorContext) {\n    super(`${resource} not found`, 404, 404, true, context);\n  }\n}\n\nexport class TimeoutError extends ApplicationError {\n  constructor(operation: string, timeout: number, context?: ErrorContext) {\n    super(`${operation} timed out after ${timeout}ms`, 408, 408, true, context);\n  }\n}\n\nexport class RateLimitError extends ApplicationError {\n  constructor(message: string = 'Rate limit exceeded', context?: ErrorContext) {\n    super(message, 429, 429, true, context);\n  }\n}\n\nexport class ExternalServiceError extends ApplicationError {\n  constructor(service: string, message: string, context?: ErrorContext) {\n    super(`External service error (${service}): ${message}`, 502, 502, true, context);\n  }\n}\n\nexport class ErrorHandler {\n  private logger = new Logger('ErrorHandler');\n\n  /**\n   * Handle application errors with proper logging and response formatting\n   */\n  public handleError(error: Error, context?: ErrorContext): ErrorResponse {\n    const timestamp = new Date().toISOString();\n    const requestId = context?.request?.headers?.['x-request-id'] as string;\n\n    // Log the error with context\n    this.logger.errorWithStack('Application error occurred', error, {\n      context,\n      requestId,\n      timestamp\n    });\n\n    // Determine error type and response\n    if (error instanceof ApplicationError) {\n      return {\n        error: error.name,\n        message: error.message,\n        code: error.statusCode,\n        timestamp,\n        requestId,\n        details: process.env.NODE_ENV === 'development' ? {\n          stack: error.stack,\n          context: error.context\n        } : undefined\n      };\n    }\n\n    // Handle specific known errors\n    if (error.message?.includes('Invalid TLD')) {\n      return {\n        error: 'ValidationError',\n        message: 'Invalid URL or domain',\n        code: 400,\n        timestamp,\n        requestId\n      };\n    }\n\n    if (error.message?.includes('ERR_NAME_NOT_RESOLVED')) {\n      return {\n        error: 'NotFoundError',\n        message: 'Domain could not be resolved',\n        code: 404,\n        timestamp,\n        requestId\n      };\n    }\n\n    if (error.message?.includes('TimeoutError') || error.name === 'TimeoutError') {\n      return {\n        error: 'TimeoutError',\n        message: 'Request timed out',\n        code: 408,\n        timestamp,\n        requestId\n      };\n    }\n\n    // Default server error\n    return {\n      error: 'InternalServerError',\n      message: process.env.NODE_ENV === 'production' \n        ? 'An internal server error occurred' \n        : error.message,\n      code: 500,\n      timestamp,\n      requestId,\n      details: process.env.NODE_ENV === 'development' ? {\n        stack: error.stack,\n        type: error.constructor.name\n      } : undefined\n    };\n  }\n\n  /**\n   * Express error handling middleware\n   */\n  public expressErrorHandler() {\n    return (err: Error, req: Request, res: Response, next: any) => {\n      const context: ErrorContext = {\n        request: req,\n        url: req.url,\n        operation: `${req.method} ${req.path}`\n      };\n\n      const errorResponse = this.handleError(err, context);\n      \n      // Set CORS headers if needed\n      if (req.headers.origin) {\n        res.setHeader('Access-Control-Allow-Origin', req.headers.origin);\n        res.setHeader('Access-Control-Allow-Credentials', 'true');\n      }\n\n      res.status(errorResponse.code).json(errorResponse);\n    };\n  }\n\n  /**\n   * Async operation wrapper that handles errors gracefully\n   */\n  public async safeExecute<T>(\n    operation: () => Promise<T>,\n    context?: ErrorContext,\n    fallback?: T\n  ): Promise<T | undefined> {\n    try {\n      return await operation();\n    } catch (error: any) {\n      const errorResponse = this.handleError(error, context);\n      \n      if (error instanceof ApplicationError && error.isOperational) {\n        // Log operational errors as warnings\n        this.logger.warn('Operational error in safe execution', {\n          error: errorResponse,\n          context\n        });\n      } else {\n        // Log programming errors as errors\n        this.logger.errorWithStack('Programming error in safe execution', error, {\n          context\n        });\n      }\n\n      return fallback;\n    }\n  }\n\n  /**\n   * Wrap async functions with error boundaries\n   */\n  public wrapAsync(fn: (req: Request, res: Response, next: any) => Promise<any>) {\n    return (req: Request, res: Response, next: any) => {\n      Promise.resolve(fn(req, res, next)).catch(next);\n    };\n  }\n\n  /**\n   * Circuit breaker pattern for external service calls\n   */\n  public async withCircuitBreaker<T>(\n    operation: () => Promise<T>,\n    circuitBreakerKey: string,\n    fallback?: T,\n    timeout: number = 5000\n  ): Promise<T> {\n    // Simple circuit breaker implementation\n    const startTime = Date.now();\n    \n    try {\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(() => reject(new TimeoutError('Circuit breaker', timeout)), timeout);\n      });\n\n      const result = await Promise.race([operation(), timeoutPromise]);\n      \n      // Log successful operation\n      this.logger.debug('Circuit breaker operation succeeded', {\n        key: circuitBreakerKey,\n        duration: Date.now() - startTime\n      });\n\n      return result;\n      \n    } catch (error: any) {\n      this.logger.warn('Circuit breaker operation failed', {\n        key: circuitBreakerKey,\n        error: error.message,\n        duration: Date.now() - startTime\n      });\n\n      if (fallback !== undefined) {\n        return fallback;\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Retry mechanism with exponential backoff\n   */\n  public async withRetry<T>(\n    operation: () => Promise<T>,\n    maxRetries: number = 3,\n    baseDelay: number = 1000,\n    context?: ErrorContext\n  ): Promise<T> {\n    let lastError: Error = new Error('Unknown error');\n    \n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error: any) {\n        lastError = error;\n        \n        this.logger.debug('Retry attempt failed', {\n          attempt,\n          maxRetries,\n          error: error.message,\n          context\n        });\n\n        // Don't retry on certain error types\n        if (error instanceof ValidationError || \n            error instanceof NotFoundError ||\n            error.message?.includes('Invalid TLD')) {\n          throw error;\n        }\n\n        if (attempt < maxRetries) {\n          const delay = baseDelay * Math.pow(2, attempt - 1); // Exponential backoff\n          await new Promise(resolve => setTimeout(resolve, delay));\n        }\n      }\n    }\n\n    throw new ApplicationError(\n      `Operation failed after ${maxRetries} attempts: ${lastError.message}`,\n      500,\n      500,\n      true,\n      context\n    );\n  }\n\n  /**\n   * Resource cleanup helper\n   */\n  public async cleanupResources(resources: Array<{ cleanup: () => Promise<void> | void; name: string }>) {\n    const cleanupPromises = resources.map(async (resource) => {\n      try {\n        await resource.cleanup();\n        this.logger.debug(`Resource cleaned up: ${resource.name}`);\n      } catch (error: any) {\n        this.logger.warn(`Failed to cleanup resource: ${resource.name}`, { error: error.message });\n      }\n    });\n\n    await Promise.allSettled(cleanupPromises);\n  }\n}\n\n// Export singleton instance\nexport const errorHandler = new ErrorHandler();\n"],
  "mappings": "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",
  "names": []
}
