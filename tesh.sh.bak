#!/bin/bash

# Configure script settings
VERBOSE=true
NPM_TEST_TIMEOUT=${NPM_TEST_TIMEOUT:-5}
DOCKER_BUILD_TIMEOUT=${DOCKER_BUILD_TIMEOUT:-300}
FORCE_BUILD=false

# Process command-line arguments
while [[ "$1" != "" ]]; do
    case $1 in
        --quiet ) VERBOSE=false ;;
        --verbose ) VERBOSE=true ;;
        --force ) FORCE_BUILD=true ;;
    esac
    shift
done

# Logging function wrapper
log() {
    if [ "$VERBOSE" = true ]; then
        printf "[%s] %s\n" "$(date '+%Y-%m-%d %H:%M:%S')" "$1"
    fi
}

# Utility functions for output and command execution
print_status() { log "\033[0;34m[INFO]\033[0m $1"; }
print_success() { log "\033[0;32m[SUCCESS]\033[0m $1"; }
print_error() { log "\033[0;31m[ERROR]\033[0m $1"; }
print_warning() { log "\033[0;33m[WARNING]\033[0m $1"; }

# Check if required dependencies are installed
check_dependency() {
    if ! command -v "$1" >/dev/null 2>&1; then
        print_error "Dependency '$1' is not installed. Please install it and try again."
        exit 1
    fi
}

# Function to retry commands
retry() {
    local cmd="$1"
    local max_attempts="${2:-3}"
    local delay="${3:-5}"
    local attempt=1

    while [ $attempt -le "$max_attempts" ]; do
        if eval "$cmd"; then
            return 0
        fi

        print_warning "Command failed (attempt $attempt/$max_attempts). Retrying in ${delay}s..."
        sleep "$delay"
        ((attempt++))
    done

    return 1
}

run_with_timeout() {
    local cmd="$1"
    local timeout_msg="$2"
    local timeout=${3:-10}
    local output
    local exit_code
    local timeout_cmd=""
    # Determine which timeout command is available (gtimeout on mac via coreutils, or timeout)
    if command -v gtimeout >/dev/null 2>&1; then
        timeout_cmd="gtimeout"
    elif command -v timeout >/dev/null 2>&1; then
        timeout_cmd="timeout"
    fi

    # If we have an external timeout command, prefer it (keeps behavior consistent)
    if [ -n "$timeout_cmd" ]; then
        if [ "$VERBOSE" = true ]; then
            $timeout_cmd $timeout bash -c "$cmd"
            exit_code=$?
        else
            output=$($timeout_cmd $timeout bash -c "$cmd" 2>&1)
            exit_code=$?
        fi

        # GNU timeout returns 124 on timeout
        if [ $exit_code -eq 124 ]; then
            print_error "$timeout_msg"
            return 1
        elif [ $exit_code -ne 0 ]; then
            print_error "Command failed with exit code $exit_code"
            if [ "$VERBOSE" = false ] && [ -n "$output" ]; then
                echo "--- Command Output ---"
                echo "$output"
                echo "--- End Output ---"
            fi
            return $exit_code
        else
            return 0
        fi
    fi

    # No external timeout available: use an internal watchdog that kills the process after timeout
    print_warning "No timeout utility found. Using internal watchdog (will kill process after ${timeout}s)."

    if [ "$VERBOSE" = true ]; then
        # Run command live and enforce timeout by watcher. Use a stable marker and
        # kill the whole process group so child daemons started by npm are
        # terminated as well.
        marker=$(mktemp /tmp/timeout_marker.XXXXXX)

        bash -c "$cmd" &
        child=$!

        (
            sleep "$timeout"
            if kill -0 "$child" >/dev/null 2>&1; then
                # mark timeout and terminate the whole process group
                : >"$marker"
                # get process group id and kill it
                pgid=$(ps -o pgid= "$child" | tr -d ' ')
                if [ -n "$pgid" ]; then
                    kill -TERM -"$pgid" >/dev/null 2>&1 || true
                    sleep 1
                    kill -KILL -"$pgid" >/dev/null 2>&1 || true
                else
                    kill -TERM "$child" >/dev/null 2>&1 || true
                    sleep 1
                    kill -KILL "$child" >/dev/null 2>&1 || true
                fi
            fi
        ) &
        watcher=$!

        wait "$child"
        exit_code=$?
        kill "$watcher" >/dev/null 2>&1 || true

        if [ -f "$marker" ]; then
            rm -f "$marker"
            print_error "$timeout_msg"
            return 1
        fi

        if [ $exit_code -ne 0 ]; then
            print_error "Command failed with exit code $exit_code"
            return $exit_code
        fi
        return 0
    else
        # Capture output to a temp file so we can show it on failure
        tmpout=$(mktemp)
        marker=$(mktemp /tmp/timeout_marker.XXXXXX)
        bash -c "$cmd" >"$tmpout" 2>&1 &
        child=$!

        (
            sleep "$timeout"
            if kill -0 "$child" >/dev/null 2>&1; then
                : >"$marker"
                pgid=$(ps -o pgid= "$child" | tr -d ' ')
                if [ -n "$pgid" ]; then
                    kill -TERM -"$pgid" >/dev/null 2>&1 || true
                    sleep 1
                    kill -KILL -"$pgid" >/dev/null 2>&1 || true
                else
                    kill -TERM "$child" >/dev/null 2>&1 || true
                    sleep 1
                    kill -KILL "$child" >/dev/null 2>&1 || true
                fi
            fi
        ) &
        watcher=$!

        wait "$child"
        exit_code=$?
        kill "$watcher" >/dev/null 2>&1 || true

        if [ -f "$marker" ]; then
            rm -f "$marker"
            print_error "$timeout_msg"
            echo "--- Command Output ---"
            cat "$tmpout"
            echo "--- End Output ---"
            rm -f "$tmpout"
            return 1
        fi

        if [ $exit_code -ne 0 ]; then
            print_error "Command failed with exit code $exit_code"
            if [ -s "$tmpout" ]; then
                echo "--- Command Output ---"
                cat "$tmpout"
                echo "--- End Output ---"
            fi
            rm -f "$tmpout"
            return $exit_code
        fi

        rm -f "$tmpout"
        return 0
    fi
}

# Check dependencies
check_dependency "npm"
check_dependency "docker"
check_dependency "docker-compose"

# Directory that contains the node project (defaults to backend/functions if present)
NPM_DIR="./backend/functions"
if [ ! -d "$NPM_DIR" ]; then
    NPM_DIR="."
fi

# Detect pyright / python availability (we don't want to depend on `uv`)
if command -v pyright >/dev/null 2>&1; then
    HAS_PYRIGHT=true
    PYRIGHT_CMD="pyright"
elif command -v python3 >/dev/null 2>&1; then
    HAS_PYRIGHT=false
    PYTHON_CMD="python3"
elif command -v python >/dev/null 2>&1; then
    HAS_PYRIGHT=false
    PYTHON_CMD="python"
else
    HAS_PYRIGHT=false
    PYTHON_CMD=""
fi

# Step 1: Install dependencies (if needed)
print_status "Step 1: Checking dependencies..."
# Install npm deps in the node project directory
if ! (cd "$NPM_DIR" && npm install); then
    print_error "npm install failed in $NPM_DIR!"
    exit 1
else
    print_success "Dependencies installed successfully!"
fi

# Step 2: Run tests
print_status "Step 2: Running npm tests..."
if ! run_with_timeout "(cd '$NPM_DIR' && npm test)" "npm tests timed out" "$NPM_TEST_TIMEOUT"; then
    print_error "npm tests failed or timed out!"
    # Re-run without timeout to show full failure output for debugging
    print_status "Re-running npm test in $NPM_DIR for debug (no timeout)..."
    (cd "$NPM_DIR" && npm test)
    exit 1
else
    print_success "npm tests passed!"
fi

# Step 3: Running Pyright...
print_status "Step 3: Running Pyright..."
if [ "$HAS_PYRIGHT" = true ]; then
    if ! run_with_timeout "$PYRIGHT_CMD demo.py" "Pyright check timed out" 5; then
        print_error "Pyright check failed or took longer than 5 seconds!"
        exit 1
    else
        print_success "Pyright check passed!"
    fi
else
    if [ -n "$PYTHON_CMD" ]; then
        print_warning "pyright not found; attempting 'python -m pyright' if available via python module"
        if ! run_with_timeout "$PYTHON_CMD -m pyright demo.py" "Pyright check timed out" 5; then
            print_warning "Pyright (via python -m) failed or is not installed; skipping Pyright check"
        else
            print_success "Pyright check (via python -m) passed!"
        fi
    else
        print_warning "pyright and python not found; skipping Pyright check"
    fi
fi

# Step 4: Run demo.py
print_status "Step 4: Running demo.py..."
if [ -n "$PYTHON_CMD" ]; then
    if ! run_with_timeout "$PYTHON_CMD demo.py" "demo.py timed out" 5; then
        print_error "demo.py failed or took longer than 5 seconds!"
        exit 1
    else
        print_success "demo.py completed successfully!"
    fi
else
    print_warning "python not found; skipping demo.py run"
fi

print_status "All steps completed successfully!"
